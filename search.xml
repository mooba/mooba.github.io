<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一文搞懂springboot定时任务</title>
      <link href="/2019/12/30/yi-wen-gao-dong-springboot-ding-shi-ren-wu/"/>
      <url>/2019/12/30/yi-wen-gao-dong-springboot-ding-shi-ren-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在springboot中自带了一个轻量级的调度系统。如果我们希望在特定的时间或者以特定的时间间隔完成某些任务，那么它完全能够满足需求，不需要再额外引入像<code>Quartz</code>这种略显沉重的调度框架。下面我们就来介绍springboot中<code>@scheduled</code> 注解的用法。</p><blockquote><p>环境：springboot 2.2.2</p></blockquote><h2 id="常用简单定时任务"><a href="#常用简单定时任务" class="headerlink" title="常用简单定时任务"></a>常用简单定时任务</h2><p>首先，为了使用springboot中的定时任务，需要在springboot应用中加入 <code>@EnableScheduling</code> 注解。该注解开启对定时任务的支持，而且确保使用<strong>单线程</strong>创建任务执行器（task executor）:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableScheduling</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringbootSchedulerApplication</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringbootSchedulerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后我们就可以在一个被 <code>@Component</code> 标注的类（表示被纳入spring的管理）中加入我们的需要调度的任务：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScheduledTask</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> DateTimeFormatter dateTimeFormatter <span class="token operator">=</span> DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithFixedDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithInitialDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithCronExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面来具体看看它支持的各种类型的调度任务。</p><h3 id="Fixed-Rate调度任务："><a href="#Fixed-Rate调度任务：" class="headerlink" title="Fixed Rate调度任务："></a>Fixed Rate调度任务：</h3><pre class=" language-Java"><code class="language-Java">  @Scheduled(fixedRate = 2000)  public void scheduleTaskWithFixedRate() {      logger.info("Fixed Rate Task :: Execution Time - {}", dateTimeFormatter.format(LocalDateTime.now()) );  }</code></pre><p>在 <code>@Scheduled</code> 注解中，用 <code>fixedRate</code> 参数可以使得该任务以一个<strong>指定的时间间隔</strong>运行，单位为毫秒。在上例中，任务每两秒钟运行一次，并且即使上一次对任务的调用没有完成，也会按指定的间隔调用<code>fixedRate</code> 任务。<br>输出：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">52</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO <span class="token operator">|</span> Started SpringbootSchedulerApplication in <span class="token number">1.028</span> <span class="token function">seconds</span> <span class="token punctuation">(</span>JVM running <span class="token keyword">for</span> <span class="token number">1.513</span><span class="token punctuation">)</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">52</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">52</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">54</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">54</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">56</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">56</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h3 id="Fixed-Delay调度"><a href="#Fixed-Delay调度" class="headerlink" title="Fixed Delay调度"></a>Fixed Delay调度</h3><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedDelay <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithInitialDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Fixed Delay Task :: Execution Time - {}"</span><span class="token punctuation">,</span> dateTimeFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Ran into an error {}"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">46</span><span class="token operator">:</span><span class="token number">58</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO <span class="token operator">|</span> Started SpringbootSchedulerApplication in <span class="token number">0.983</span> <span class="token function">seconds</span> <span class="token punctuation">(</span>JVM running <span class="token keyword">for</span> <span class="token number">1.416</span><span class="token punctuation">)</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">46</span><span class="token operator">:</span><span class="token number">58</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Delay Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">46</span><span class="token operator">:</span><span class="token number">58</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">47</span><span class="token operator">:</span><span class="token number">03</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Delay Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">47</span><span class="token operator">:</span><span class="token number">03</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">47</span><span class="token operator">:</span><span class="token number">08</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Delay Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">47</span><span class="token operator">:</span><span class="token number">08</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p><code>fixedDelay</code> 参数可以使得您可以在上一次调用完成与下一次调用开始之间以固定的延迟执行任务。这种方式适合于下一次的任务对上一次任务的结果有依赖的情况。从输出也可以看到，日志输出的间隔时间是任务执行时间加上<code>fixedDelay</code> 参数所指定的时间。</p><h3 id="Initial-Delay"><a href="#Initial-Delay" class="headerlink" title="Initial Delay"></a>Initial Delay</h3><p>这种情况是是和上面两种情况搭配使用的，就是不管是使用 <code>fixedRate</code> 参数还是 <code>fixedDelay</code> 都可以使用该参数使得任务的初次执行得到延缓。如下例所示：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> initialDelay <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithInitialDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Fixed Rate Task with Initial Delay :: Execution Time - {}"</span><span class="token punctuation">,</span> dateTimeFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>2019-12-29 17:47:46 [main] INFO | Started SpringbootSchedulerApplication in 1.081 seconds (JVM running for 1.642)2019-12-29 17:47:56 [scheduling-1] INFO | Fixed Rate Task with Initial Delay :: Execution Time - 17:47:562019-12-29 17:47:58 [scheduling-1] INFO | Fixed Rate Task with Initial Delay :: Execution Time - 17:47:582019-12-29 17:48:00 [scheduling-1] INFO | Fixed Rate Task with Initial Delay :: Execution Time - 17:48:00</code></pre><p>在输出中我特意把日志框架打印日志的时间戳给了出来，可以看到 <code>SpringbootSchedulerApplication</code> 启动之后隔了十秒钟（正是<code>initialDelay</code>所指定的延迟时间），调度任务才开始按正常的频率执行。</p><h3 id="Cron表达式任务"><a href="#Cron表达式任务" class="headerlink" title="Cron表达式任务"></a>Cron表达式任务</h3><p>既然是定时任务，又怎么少得了强大的Cron表达式呢。比如在某一个实际应用场景中，我需要在<strong>每天早上九点</strong>把应用的统计信息发到工作群里面，那么我就可以如下配置定时任务：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>cron <span class="token operator">=</span> <span class="token string">"0 0 9 * * ?"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsgTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"sending statistic message with scheduled task"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sendMsgMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="参数化定时任务"><a href="#参数化定时任务" class="headerlink" title="参数化定时任务"></a>参数化定时任务</h3><p>把定时任务的参数硬编码到代码中固然简单，但是当我们需要更改这些参数的时候就需要更改代码然后重新编译部署。这种时候把定时任务参数中写到<strong>配置文件</strong>中，然后使用Spring表达式注入到代码中是更好的选择。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// A fixedDelay task:</span><span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedDelayString <span class="token operator">=</span> <span class="token string">"${fixedDelay.in.milliseconds}"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// A fixedRate task:</span><span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRateString <span class="token operator">=</span> <span class="token string">"${fixedRate.in.milliseconds}"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// A cron expression based task:</span><span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>cron <span class="token operator">=</span> <span class="token string">"${cron.expression}"</span><span class="token punctuation">)</span></code></pre><p>spring直接支持的简单定时任务就已经讲完了。<br>其中被 <code>@Scheduled</code> 标注的调度方法有两个需要注意的点是：</p><ol><li>返回类型应该是 <code>void</code> </li><li>方法不能有入参</li></ol><h2 id="多线程定时任务"><a href="#多线程定时任务" class="headerlink" title="多线程定时任务"></a>多线程定时任务</h2><p>从上面例子中的输出日志可以看到，调度任务的执行是在一个默认线程名为 <code>scheduling-1</code> 的独立线程中执行的。事实上，通过这种方式配置的定时任务默认是在<strong>单线程</strong>中运行的。这意味着什么呢？意味着如果当前任务任务没有运行完，可能下一个任务不会开始，即被阻塞。同一个定时任务的<strong>上一次运行</strong>或者多个定时任务之前都可能发生阻塞。在上面介绍 <code>fixedRate</code> 任务的时候，我们说到：</p><blockquote><p>即使上一次对任务的调用没有完成，也会按指定的间隔调用 fixedRate 任务<br>但是实验发现，这可以说只是它的“设计目标”，实际上指定间隔到了之后，如果上一次的任务还没有执行完会发生什么呢？</p></blockquote><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Fixed Rate Task :: Execution Time - {}"</span><span class="token punctuation">,</span> dateTimeFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">19</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">19</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">22</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">22</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">25</span></code></pre><p>可以看到，<code>fixedRate</code>虽然指定的是两秒，但是执行结果却是三秒一次，也就是每次任务的执行时间（用sleep表示）。如果是多个不同的定时任务，如果其中一个定时任务指定完之后已经过了另外一个任务应该执行的时间点了，那么这个“定时”就已经不再是准确意义上的定时了，我们把这称为<strong>问题B</strong>。这两种情况总结成如下<strong>问题定义</strong></p><ul><li><strong>问题A</strong> 同一个定时任务多次运行，按时间排队运行；</li><li><strong>问题B</strong> 多个定时任务时间冲突，排队运行。</li></ul><p>这两个问题发生的根本原因就是 <code>@EnableScheduling</code> 开启的调度默认是使用单线程（更严谨一点是线程数为1的线程池）执行 task 的，任务排队调用。<br>那么就可以自然而然地想到，解决方式就是使用线程池。</p><h2 id="定时任务指定线程池"><a href="#定时任务指定线程池" class="headerlink" title="定时任务指定线程池"></a>定时任务指定线程池</h2><p>在jdk中，我们使用 <code>Timer</code> 来执行定时任务，spring 为这种调度提供了自己的抽象–<code>TaskScheduler</code>，提供如下抽象方法及多个重载：</p><pre><code>schedule()scheduleAtFixedRate()scheduleWithFixedDelay()</code></pre><p>这和我们之前用注解的方式实现的调度任务对比一下就能发现他们之间的联系：注解的底层就是用这个抽象来实现功能的。<br>我们可以通过为 spring 提供配置过的 <code>TaskScheduler</code> 的 bean 来覆盖默认的单线程配置。而  <code>TaskScheduler</code> 是一个接口，其实现类 <code>ThreadPoolTaskScheduler</code> 才是我们通常使用的目标，实现 <code>SchedulingConfigurer</code> 接口就能对其进行配置 ：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SchedulerConfig</span> <span class="token keyword">implements</span> <span class="token class-name">SchedulingConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configureTasks</span><span class="token punctuation">(</span>ScheduledTaskRegistrar scheduledTaskRegistrar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolTaskScheduler scheduler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduler<span class="token punctuation">.</span><span class="token function">setPoolSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduler<span class="token punctuation">.</span><span class="token function">setThreadNamePrefix</span><span class="token punctuation">(</span><span class="token string">"schedule-task-pool-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduler<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduledTaskRegistrar<span class="token punctuation">.</span><span class="token function">setTaskScheduler</span><span class="token punctuation">(</span>scheduler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到，这里可以通过 <code>setPoolSize()</code> 方法设置线程池的大小，并且可以通过 <code>setThreadNamePrefix()</code> 方法设置线程池名字的前缀，方便跟踪调试。需要注意的是配置好参数只会一定要调用 <code>initialize()</code> 方法，否则会报错：</p><pre><code>java.lang.IllegalStateException: ThreadPoolTaskScheduler not initialized</code></pre><p>如果需要对线程池进行更精细的控制，<code>ThreadPoolTaskScheduler</code> 本身的类方法还不够，但是可以通过 spring 封装的线程池类 <code>ThreadPoolTaskExecutor</code> 进行间接设置：</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configureTasks</span><span class="token punctuation">(</span>ScheduledTaskRegistrar scheduledTaskRegistrar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolTaskExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setThreadNamePrefix</span><span class="token punctuation">(</span><span class="token string">"scheduled-pool-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadPoolTaskScheduler scheduler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduler<span class="token punctuation">.</span><span class="token function">setThreadFactory</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduler<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduledTaskRegistrar<span class="token punctuation">.</span><span class="token function">setTaskScheduler</span><span class="token punctuation">(</span>scheduler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>或者也可以直接通过提供 <code>ThreadPoolTaskExecutor</code> 的 bean 配置线程池：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ThreadPoolTaskExecutor <span class="token function">getExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolTaskExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setQueueCapacity</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> executor<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>配置好线程池之后，我们来运行一下同时包含上述 <code>fixedRate</code> 和 <code>fixedDelay</code> 两个定时任务的应用，输出如下：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">35</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">35</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">35</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Delay Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">35</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">37</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">37</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">39</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">39</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">40</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Delay Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">40</span></code></pre><p>这时，不同的定时任务可以在不同的线程中得到并发。上述<strong>问题B</strong>得到了解决。<br>再来看<strong>问题A</strong>，配置了线程池之后再重新运行以下代码：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Fixed Rate Task :: Execution Time - {}"</span><span class="token punctuation">,</span> dateTimeFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">25</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">28</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">28</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">31</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">31</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">34</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">34</span></code></pre><p>很不幸的是，从输出可以看出虽然每次执行都可能使用不同的线程，但是依然会等到上一次任务执行完成之后才会开始下一次执行，因为间隔时间是3秒而不是2秒。这说明即使配置了线程池也<strong>无法让同一个定时任务的多次运行之间并发</strong>。<br>要<strong>实现同一个任务的并发</strong>这个目的，需要使用<strong>异步执行</strong>。首先像上面的  <code>@EnableScheduling</code> 一样，使用 <code>@EnableAsync</code> 开启对异步的支持。然后在调度任务上使用 <code>@Async</code> 注解表示该方法是个异步任务：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Async</span><span class="token punctuation">(</span><span class="token string">"taskExecutor"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 可以根据bean name指定线程池</span>    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Fixed Rate Task :: Execution Time - {}"</span><span class="token punctuation">,</span> dateTimeFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">04</span> <span class="token punctuation">[</span>taskExecutor<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">04</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">06</span> <span class="token punctuation">[</span>taskExecutor<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">06</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">08</span> <span class="token punctuation">[</span>taskExecutor<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">08</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>这次可以看到该任务的每次运行使用不同的线程，并且可以做到并发。这样就解决了上述的<strong>问题B</strong>。<br>进一步地，如果并发任务可以通过 <code>@Async</code> 指定某个具体的线程池的话，那么可以提供多线程池的bean，然后通过 <code>@Async</code> 把不同的任务分配到不同的线程池中去执行。<br>对于 <code>@Async</code> 标注的方法，有两点需要注意的：</p><ol><li>它只能用于 <code>public</code> 方法；</li><li>如果它被类内部的方法调用的话，异步功能无法生效。<br>这两点其实在使用代理实现功能的注解上都需要注意，比如说用于缓存的 <code>@Cacheable</code> 注解。因为方法只有是 <code>public</code> 的才能被正确代理，并且如果调用来自类内的话，就会越过代理而调用真实方法，无法实现注解所表示的功能。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了springboot自带的定时任务的基本用法及他们之间的区别，对于简单的业务场景，这种 out-of-box 的工具对用户是非常友好的。同时也指出了其默认使用单线程处理同一个任务的多次运行以及多个任务的运行，这样对于较为耗时的操作可能会导致阻塞。然后针对这两种情况给出了使用多线程运行定时任务的方案。</p><p>文中代码可在<a href="https://github.com/mooba/springBoot-study/tree/master/springboot-scheduler" target="_blank" rel="noopener">GitHub</a>找到。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
            <tag> scheduler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[译]理解compare-and-swap（CAS）</title>
      <link href="/2019/11/22/yi-li-jie-compare-and-swap-cas/"/>
      <url>/2019/11/22/yi-li-jie-compare-and-swap-cas/</url>
      
        <content type="html"><![CDATA[<p><em>compare-and-swap (CAS)</em> 指令是一个不可中断的操作（原子操作），它读取一个<strong>内存地址</strong>，把<strong>读取到的值</strong>和一个<strong>期望值</strong>进行比较，当读取的值和期望值相等的时候，就把该内存地址的值更新为一个新的值，否则就什么也不做。这个过程根据不同的微处理器指令可能有些许不同（比如，如果 CAS 成功的话返回 true，否则返回 false，而不是下面实例中的做法——返回读取的值）。</p><blockquote><p><strong>微处理器 CAS 指令</strong>：</p><p>现代的微处理器本省提供了某种 CAS 指令。比如说，Intel 微处理器提供了 <code>cmpxchg</code> 指令族，而 PowerPC 微处理器提供了 <code>load-link</code>（e.g., <code>lwarx</code>）和 <code>store-conditional</code>（e.g., <code>stwcx</code>）指令用于相同的目的。</p></blockquote><p>CAS 使得 <strong>read-modify-write</strong> <strong>操作序列</strong>作为原子操作成为可能。通常我们会按照如下过程使用 CAS：</p><ol><li>从地址X读取值v</li><li>执行一个多步计算得到一个新的值v2</li><li>使用CAS尝试把地址X上的值从v改成v2，当执行这些步骤时X的值未更改，则CAS执行成功。</li></ol><p>为了搞清楚CAS是怎样比<code>synchronization</code>提供更好的性能（和可扩展性），举个例子：有一个计数器，允许你读它的当前值并且对值进行累加。下面的类基于<code>synchronization</code>实现了一个计数器：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Counter.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token operator">++</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>monitor lock 的高竞争会导致大量的上下文切换，从而使所有的线程延迟，并导致应用程序无法很好地扩展。</p><p>取而代之的是使用 CAS 的代码实现<code>compare-and-swap</code>操作。下面的类模拟了 CAS ，但是使用的是<code>synchronized</code>而不是实际的硬件指令，用于简化代码:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// EmulatedCAS.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmulatedCAS</span><span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">compareAndSwap</span><span class="token punctuation">(</span><span class="token keyword">int</span> expectedValue<span class="token punctuation">,</span> <span class="token keyword">int</span> newValue<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">int</span> readValue <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>readValue <span class="token operator">==</span> expectedValue<span class="token punctuation">)</span>         value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>      <span class="token keyword">return</span> readValue<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中，<code>value</code>代表了一个内存地址，可以通过<code>getValue()</code>方法获取值。相应地，<code>compareAndSwap()</code>实现了 CAS 算法。</p><p>下面一个类使用<code>EmulatedCAS</code>实现了一个<code>non-synchronized</code>的计数器（这里假设<code>EmulatedCAS</code>不需要<code>synchronized</code>）:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Counter.java (version 2)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> EmulatedCAS value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EmulatedCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">int</span> readValue <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">compareAndSwap</span><span class="token punctuation">(</span>readValue<span class="token punctuation">,</span> readValue<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> readValue<span class="token punctuation">)</span>         readValue <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> readValue<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Counter</code>封装了<code>EmulatedCAS</code>实例，并且通过这个实例提供的功能声明了用于获取值和增加计数器值的方法。即，<code>getValue()</code>获取该实例的“当前计数器值”，<code>increment()</code>安全地增加计数器的值。</p><p><code>increment()</code>重复调用<code>compareAndSwap()</code> 直到 <code>readValue</code>的值不再改变，然后就可以改变这个值了。当没有锁牵涉其中的时候，就可以避免竞争以及随之而来的大量上下文切换了。这样性能和代码的可扩展性就能得到提高。</p><blockquote><p>你可能之前了解到<code>ReentrantLock</code> 在高线程争用情况下能够比 <code>synchronized</code>提供更好的性能表现。为了提高性能，<code>ReentrantLock</code>的同步是通过抽象类<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>的一个子类来管理的。进一步地，该类利用了未开源的<code>sun.misc.Unsafe</code>类中的<code>compareAndSwapInt()</code>这个 CAS 实现。</p></blockquote><p><a href="https://www.javaworld.com/article/2078848/java-concurrency-java-101-the-next-generation-java-concurrency-without-the-pain-part-2.html?page=3" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> CAS </tag>
            
            <tag> concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j和log4j2在springboot中的性能对比</title>
      <link href="/2019/11/17/log4j-he-log4j2-zai-springboot-zhong-de-xing-neng-dui-bi/"/>
      <url>/2019/11/17/log4j-he-log4j2-zai-springboot-zhong-de-xing-neng-dui-bi/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 java 项目中最常用的三大日志框架是<code>logback</code>，<code>log4j</code>，<code>log4j2</code>。其中<code>logback</code>是 springboot 的默认框架。由于历史原因，我手上有个springboot项目的日志框架是用的<code>log4j</code>。在对某个接口进行压测和性能优化的时候发现，打印同步日志会导致接口的性能缩水，所以当时直接把性能要求高的接口的日志关闭掉了。随着系统的逐渐复杂，重要性越来越高，定位问题的难度越来越大，我逐渐感觉到日志的的重要性。所以优化日志势在必行。<br>我是从两个方面来考虑<strong>优化日志</strong>这个问题的。</p><ol><li>更换性能更高的日志框架；</li><li>使用异步日志或者延时刷盘的日志配置。</li></ol><p>对第一个问题，很容易就可以Google到，目前性能表现最好的日志框架是<code>log4j2</code>，所以直接把日志框架替换成<code>log4j2</code>就可以了。</p><p>对于第二个问题，因为当前日志是同步的，需要把“打印日志”这个操作完成之后才会运行接下来的业务代码，而“打印日志”通常是要输出到控制台或者文件中的，IO开销很大，如果把这个过程变成异步的应该能从一定程度上提高性能表现。</p><p>不知道在哪听到的两句话，想在这里分享一下：</p><ol><li>没有日志的系统就像在裸奔</li><li>没有uid的日志是没有灵魂的</li></ol><p>PS：这里没有uid的本来是指是调用方的id，更一般的说法就是不能定位问题的日志是没有存在价值的。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>springboot 2.1.5</li><li>java 8</li><li>MacBook Pro 2017</li></ul><h2 id="log4j日志"><a href="#log4j日志" class="headerlink" title="log4j日志"></a>log4j日志</h2><h3 id="log4j-在-springboot-中的配置"><a href="#log4j-在-springboot-中的配置" class="headerlink" title="log4j 在 springboot 中的配置"></a>log4j 在 springboot 中的配置</h3><p>在 springboot 中使用 log4j 需要引入其依赖并把 springboot 自带的日志框架 logback 排除掉:</p><pre class=" language-xml"><code class="language-xml">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.8.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>然后编写配置文件<code>log4j.properties</code>:</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">log4j.rootLogger</span><span class="token punctuation">=</span><span class="token attr-value">INFO,stdout,file</span><span class="token attr-name">log4j.appender.stdout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.ConsoleAppender</span><span class="token attr-name">log4j.appender.stdout.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.stdout.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%d{yyyy-MM-dd HH:mm:ss} [%p] %c:[%L] %m%n</span><span class="token attr-name">log4j.appender.file</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.DailyRollingFileAppender</span><span class="token attr-name">log4j.appender.file.File</span><span class="token punctuation">=</span><span class="token attr-value">logs/seller_penalty_api_server.log</span><span class="token attr-name">log4j.appender.file.Append</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">log4j.appender.file.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.file.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%d{yyyy-MM-dd HH:mm:ss} [%p] %c:[%L] %m%n</span></code></pre><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>知己知彼，百战不殆。</p><p>要对比性能，首先就要知道原来的<code>log4j</code>框架的性能表现如何。</p><p>这里我使用了一种简单的方式来进行对比。在 springboot 中实现两个简单的接口，一个打印一行日志，一个不打印日志，然后用<code>wrk</code>工具对接口进行压测，看两个接口能够达到的QPS分别是多少。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 不打印日志</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/ping"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">"pang"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 打印日志</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"pingLog"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">pingWithLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"calling /pingLog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token string">"pangLog"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>压测配置如下，分别对两个接口进行多次压测，取三次作为采样结果。</p><pre class=" language-shell"><code class="language-shell">wrk -t10 -c250 -d30s http://localhost:8080/ping</code></pre><table><thead><tr><th>采样次数</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>不打印日志</td><td>21937.40</td><td>23570.31</td><td>22950.31</td></tr><tr><td>打印日志</td><td>7825.40</td><td>7848.33</td><td>7788.54</td></tr></tbody></table><p>可以看到两种情况基本上有将近三倍的差距。我是用nohup后台运行的，如果直接使用<code>java -jar</code>运行，日志输出到文件的同时还会输出到控制台，这种情况QPS将进一步降低，大概在5k+左右。这也正是我们最开始为了接口性能选择关闭日志的原因</p><h2 id="log4j2"><a href="#log4j2" class="headerlink" title="log4j2"></a>log4j2</h2><p>引入log4j2（同log4j一样，要排除 springboot 自带的日志框架）：</p><pre class=" language-xml"><code class="language-xml">       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-log4j2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 增加识别yaml格式依赖，加上这个才能辨认到log4j2.yml文件 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.dataformat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-dataformat-yaml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>然后在<code>src/main/resources/</code>路径中编写<code>log4j2</code>的配置文件。默认配置文件名是<code>log4j2</code>，支持xml、properties、json、yaml多种文件格式，这里我选了yml，所以需要额外引入<code>jackson-dataformat-yaml</code>的包。</p><pre class=" language-yml"><code class="language-yml">Configuration:  status: debug  appenders: # 包含控制台和文件两个appender    Console:      name: LogToConsole      PatternLayout:        Pattern: "%d{yyyy-MM-dd HH:mm:ss} [%p] %c:[%L] %m%n"    RollingFile:      - name: LogToRollingFile        fileName: logs/seller_penalty_api_server.log        filePattern: "logs/seller_penalty_api_server.log.%d{yyyy-MM-dd}.gz" # 带有后缀名会自动压缩        PatternLayout:          pattern: "%d{yyyy-MM-dd HH:mm:ss} [%p] %c:[%L] %m%n"        Policies:          TimeBasedTriggeringPolicy: # 基于时间的trigger，每天一个文件            interval: 1  Loggers:    logger:      - name: io.shopee.bigdata.penalty.server        level: debug        additivity: false        AppenderRef:          - ref: LogToConsole          - ref: LogToRollingFile    Root:      level: error      AppenderRef:        ref: LogToConsole</code></pre><p>使用<code>log4j2</code>之后，使用<code>wrk</code>和同样的参数压测（关掉控制台输入），三次测试的QPS分别是：</p><table><thead><tr><th>采样次</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>QPS</td><td>13992.50</td><td>15562.27</td><td>15161.16</td></tr></tbody></table><p>可以看到在这个简单的场景下，性能几乎是log4j的2到3倍之多！所以很明显，首先替换日至框架是一个明智的选择。</p><h3 id="log4j2-异步日志"><a href="#log4j2-异步日志" class="headerlink" title="log4j2 异步日志"></a>log4j2 异步日志</h3><p>到目前为止，上述的测试都是针对同步日志进行的测试。在确定了<code>log4j2</code>作为日志框架之后，我想看一下，使用异步日志能不能进一步提高性能表现。</p><h3 id="AsyncAppender-和-Asynchronous-Loggers"><a href="#AsyncAppender-和-Asynchronous-Loggers" class="headerlink" title="AsyncAppender 和 Asynchronous Loggers"></a>AsyncAppender 和 Asynchronous Loggers</h3><p>在<code>log4j2</code>中异步日志有两种实现<code>AsyncAppender</code> 和 <code>Asynchronous Loggers</code> </p><p>前者是 <code>log4j2</code> 最开始的异步日志实现，它把其他 Appender 作为输入，然后把产生 <code>logEvent</code>输出到默认的容器<code>ArrayBlockingQueue</code>中，然后使用另外一个线程中来输出日志以实现异步。但是官方文档也指出：</p><blockquote><p>在这种多线程应用的实践中需要主要：阻塞队列很容易发生锁争用，测试表明当大量线程并发写日志的时候，性能甚至会变得更糟糕。所以应该考虑使用<strong>无锁的Asyn Loggers</strong>进行优化。</p></blockquote><p>上述的<code>Asyn Loggers</code>是<code>log42</code> 团队后来才加入的异步实现，连官方文档都推荐它了，那还有什么好犹豫的呢。它需要引入一个额外的依赖：</p><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.lmax<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>disruptor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><code>Disruptor</code> 通过<code>CAS</code>而不是锁实现多生产者、多消费者对<code>RingBuffer</code>的并发访问，实现高吞吐和高性能。</p><p>它们两者的具体区别可以参考<a href="https://www.cnblogs.com/yeyang/p/7944906.html" target="_blank" rel="noopener">参考资料2</a></p><h3 id="全异步和混合异步"><a href="#全异步和混合异步" class="headerlink" title="全异步和混合异步"></a>全异步和混合异步</h3><p>Log4j2的异步日志的使用又可以分为<strong>全异步</strong>和<strong>混合异步</strong>，所谓全异步就是所有的日志都以异步方式输出；混合异步就是只有指定的代码文件用异步方式输出，其他日志使用同步方式输出；前者能够获得更高的性能，也是官方推荐的方式，后者具有更好的灵活性，可以进行针对性配置。</p><p>本文中我们直接使用全异步日志。</p><p>在springboot中开启全异步的方式很简单，只需要在配置文件中加如下配置（yml）：</p><pre class=" language-yml"><code class="language-yml">log4j2:  contextSelector: org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</code></pre><p>或者在用<code>java -jar</code> 启动的时候加入系统参数：</p><pre class=" language-shell"><code class="language-shell">-DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</code></pre><p>应用启动之后按照上述的方法测试接口性能：</p><table><thead><tr><th>采样次</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>QPS</td><td>16238.76</td><td>16006.78</td><td>16322.12</td></tr></tbody></table><p>可以看到把日志从同步改成异步之后，性能有一定提升，但是并没有想象中那么大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>同步日志和业务逻辑在同一个线程中，当日志输出完毕才能执行接下来的代码，涉及到IO，非常影响性能；</li><li><code>log4j2</code> 在本文的简单场景中性能要远远高于 <code>log4j</code>，这次替换是值得的；</li><li><code>log4j2</code> 异步日志应该使用 <code>Asynchronous Loggers</code> 而不是 <code>AsyncAppender</code> </li><li>本次测试是基于一个很简单的场景，在官方文档中，异步日志的性能要远远超过同步日志的，但是在本次测试中并没有体现出来；日志在 springboot 中的性能可能受多个方面的影响，比如每个调用链中日志的条数、springboot本身的配置，日志的level、硬件环境等。</li><li>项目代码见<a href="https://github.com/mooba/springBoot-study/tree/master/springboot2-logging" target="_blank" rel="noopener">Github</a></li></ol><h2 id="彩蛋1-性能测试需要注意的点"><a href="#彩蛋1-性能测试需要注意的点" class="headerlink" title="彩蛋1-性能测试需要注意的点"></a>彩蛋1-性能测试需要注意的点</h2><p>关于性能测试，在 log4j2 的官方文档中提到的几点我觉得是比较通用的:</p><ul><li>获取性能的采样结果之前需要 <em>warm up the JVM</em>；</li><li>重复热身多次，然后等待IO线程赶上并释放缓冲区;</li><li>测试的时候重复多次取平均数。</li></ul><p>总结一下就是系统刚启动的一段时间的测试数据不能作为参考，需要压测一段时间，取稳定之后的结果。就像运动前的热身一样，不光JVM，各种线程池或连接池都需要一段时间的请求才能启动起来进入正常工作状态。</p><h2 id="彩蛋2-springboot-中多环境日志配置"><a href="#彩蛋2-springboot-中多环境日志配置" class="headerlink" title="彩蛋2-springboot 中多环境日志配置"></a>彩蛋2-springboot 中多环境日志配置</h2><p>在springboot中我们通常针对dev，test，live等多种环境会有多套配置文件，比如<code>application-dev.yml</code>,<code>application-test.yml</code>, <code>application-live.yml</code>。然后可以在启动的时候可以通过在全局配置文件<code>application.yml</code>指定某个配置文件来启用配置：</p><pre class=" language-yml"><code class="language-yml">sping:  profiles:    active: live</code></pre><p>日志同样有这样的需求，不同环境使用不同的日志配置，比如dev或test环境需要开启的log level为<code>DEBUG</code>，而在live环境中却不需要。这种时候我们只需要写多套日志配置，比如<code>log4j2-dev.yml</code>，<code>log4j2-test.yml</code>，<code>log4j2-live.yml</code>，然后在其对应的配置文件中启用日志配置就可以了：</p><pre class=" language-yml"><code class="language-yml">logging:  config: classpath:log4j2-dev.yml</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.mkyong.com/spring-boot/spring-boot-log4j-2-example/" target="_blank" rel="noopener">Spring Boot Log4j 2 example</a></li><li><a href="https://www.cnblogs.com/yeyang/p/7944906.html" target="_blank" rel="noopener">Log4j2中的同步日志与异步日志</a></li><li><a href="https://stackoverflow.com/questions/24177601/difference-between-asynclogger-and-asyncappender-in-log4j2" target="_blank" rel="noopener">Difference between Asynclogger and AsyncAppender in Log4j2</a></li><li><a href="https://www.callicoder.com/spring-boot-log4j-2-example/" target="_blank" rel="noopener">https://www.callicoder.com/spring-boot-log4j-2-example/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
            <tag> log4j2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 自动配置浅析</title>
      <link href="/2019/10/28/springboot-zi-dong-pei-zhi-qian-xi/"/>
      <url>/2019/10/28/springboot-zi-dong-pei-zhi-qian-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>我们知道，SpringBoot之所以强大，就是因为他提供了各种默认的配置，可以让我们在集成各个组件的时候从各种各样的配置文件中解放出来。</p><p>拿一个最普通的 web 项目举例。我们需要使用 servlet 容器，SpringBoot 就提供了嵌入式的 Tomcat 作为默认容器，不需要一行配置就能直接以最普通的 Java 程序的方式启动：<code>java -jar</code>；接收请求需要一个网络端口，默认配置好<code>8080</code>；处理请求需要 servlet 的多线程特性，默认配置好了最大线程数为<code>200</code>；处理好的请求以<code>Restful</code> 风格返回给调用方，SpringBoot 默认配置好了<code>jackson</code>进行 json 序列化，业务代码需要做的只是返回一个 POJO 对象；连接池直接就默认配置了性能最好的的 <code>Hikari</code>，以及连接池的默认尺寸为10……在一个简单的web应用中，这些配置我们甚至都可能不了解或者没有意识到它们的存在，就可以让程序正常运行。</p><p>这就是自动配置的魔力——润物细无声。</p><p>那么自动配置是怎么实现的呢？本文就从<code>POM</code>文件和 <code>@SpringBootApplication</code> 注解来简单分析一下自动配置原理。</p><p>真的只是<strong>简单地</strong>，分析一下。</p><h2 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>SpringBoot 2.0.6</li></ul><h3 id="父项目"><a href="#父项目" class="headerlink" title="父项目"></a>父项目</h3><p>在每一个 SpringBoot 项目一开始的 POM 文件中，就有一个<strong>父依赖</strong>：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span></code></pre><p>点进<code>artifactId</code>之后来到 <code>spring-boot-starter-parent-2.0.6.RELEASE.pom</code> 文件，这个文件还有一个父依赖：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">></span></span>../../spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relativePath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span></code></pre><p>再继续点进去来到 <code>spring-boot-dependencies-2.0.6.RELEASE.pom</code> 文件中。在该文件的 <code>&lt;properties&gt;</code> 标签中可以看到各种各样的组件的版本信息， <code>&lt;dependencyManagement&gt;</code> 标签中声明了各个组件的maven坐标信息。其中，我数了一下，在 <code>SpringBoot 2.0.6</code> 中一个有177个带有版本信息的组件名，包括了大家熟悉的 elasticsearch、activemq、redis、kafka等等。</p><p>这里（<code>spring-boot-dependencies-2.0.6.RELEASE.pom</code>文件）称为 SpringBoot 的“<strong>版本仲裁中心</strong>”，它是用来管理 SpringBoot 应用里面的所有依赖版本的地方。 它包含了大部分开发中会用到的一些组件的版本，所以我们导入依赖默认是不需要写版本号的，SpringBoot 会自动帮我们配置需要的版本。这样在引入某个组件的时候不用考虑这个组件和系统中已有的组件兼不兼容之类的问题，避免了烦人的版本冲突问题。（当然，没有在 dependencies里面管理的依赖自然需要声明版本号)  </p><h3 id="启动器（Starters）"><a href="#启动器（Starters）" class="headerlink" title="启动器（Starters）"></a>启动器（Starters）</h3><p>父项目做版本仲裁，那么真正的 jar 包是从哪里导入进来的呢？这就要说到我们的starters了。点开web-starter可以看到它帮我们导入了web模块正常运行所依赖的组件，就不用我们一个一个手动导入了。</p><p>所以，所谓的Starters就是一系列依赖描述的组合，我们可以通过导入这些starters就会有相应的依赖了并可以基于他们进行相应的开发</p><p>Springboot把开发中中会遇到的场景都抽象成一个个的starter，比如（），只需要在项目里面引入这些starter 相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>一个典型的 springboot 项目的入口类如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>DemoApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>只要运行<code>main</code>方法就能启动该应用。<code>main</code> 中运行 run 方法时需要传入一个类，这个类正是使用<code>@SpringBootApplication</code>注解标注的类，如果没有这个注解程序是跑不起来的。</p><p>这个注解标注在某个类上就说明这个类是 springboot 的主配置类，springboot 就应该运行这个类的 main 方法来启动springboot应用</p><p>点开这个注解的源码，可以看到这是一个组合注解，最主要的是这两个注解：</p><ul><li><p><code>@SpringBootConfiguration</code></p></li><li><p><code>@EnableAutoConfiguration</code> </p></li></ul><p><code>@SpringBootConfiguration</code>标注在某个类上，表示这是一个 SpringBoot 的配置类，它的底层是<code>@Configuration</code>，属于spring的底层注解，标注了这个注解的类表名这个类是一个配置类，取代以前开发中的xml文件配置，同时也表明这个类是 spring 容器中的组件，受容器管理。</p><p>接下来是<code>@EnableAutoConfiguration</code>注解，它的用处是<strong>开启自动配置</strong>，使用 spring 开发需要手动配置的东西，现在由 springboot 帮我们配置了，具体的实现就是通过这个注解来实现的。该组合注解有两个。</p><h3 id="1-AutoConfigurationPackage"><a href="#1-AutoConfigurationPackage" class="headerlink" title="1. @AutoConfigurationPackage"></a>1. @AutoConfigurationPackage</h3><p>它的 注解中的核心代码是 <code>@Import({Registrar.class})</code>。</p><p> <code>@Import</code> 的作用就是为容器中导入一个它指定的组件。</p><p>在 <code>Registrar</code> 这个类中有一个方法叫<code>registerBeanDefinitions</code>，用于注册一些 bean 定义信息：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">,</span> BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>     AutoConfigurationPackages<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AutoConfigurationPackages<span class="token punctuation">.</span>PackageImport</span><span class="token punctuation">(</span>metadata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>打个断点在这一行代码上，运行</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AutoConfigurationPackages<span class="token punctuation">.</span>PackageImport</span><span class="token punctuation">(</span>metadata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>得到的结果是<strong>主配置类所在的包名</strong>，目的就是将主配置类所在包及<strong>下面所有子包里面的所有组件扫描到Spring容器中</strong>。同时也说明了，如果在主配置所在包的上层包添加组件的话是不会被扫描到的、不起作用的。</p><h3 id="2-Import-AutoConfigurationImportSelector-class"><a href="#2-Import-AutoConfigurationImportSelector-class" class="headerlink" title="2. @Import({AutoConfigurationImportSelector.class})"></a>2. @Import({AutoConfigurationImportSelector.class})</h3><p>该注解导入了一个自动配置的<strong>选择器</strong>，真正地给容器中导入 springboot 自动帮我们配置好的配置类。在 <code>AutoConfigurationImportSelector</code> 这个选择器中的 <code>getAutoConfigurationEntry</code> 方法中，以<strong>全限定类名</strong>的方式把所有需要的配置类导入 springboot 容器中。这些全限定类型所在文件路径为：</p><pre><code>org/springframework/boot/spring-boot-autoconfigure/2.1.8.RELEASE/spring-boot-autoconfigure-2.1.8.RELEASE.jar!/META-INF/spring.factories</code></pre><p>上述两个注解一个负责扫描我们<strong>将要加容器中的类</strong>，一个加入 <strong>springboot 为我们自动配置好的类</strong>，springboot 通过这两种方式省略了我们大量的配置工作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从用于maven项目管理的<code>pom.xml</code>文件和标注在启动类上的<code>@SpringBootApplication</code>注解，简单分析了springboot 自动配置的实现。前者通过<strong>版本仲裁中心</strong>为我们维护项目组件的版本，防止依赖冲突；后者通过在加载程序的时候导入数以百计的自动配置类实现自动配置。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 简介</title>
      <link href="/2019/10/28/springboot-jian-jie/"/>
      <url>/2019/10/28/springboot-jian-jie/</url>
      
        <content type="html"><![CDATA[<p>认识一个东西我们先来试着回答三个经典的问题问题，是什么？为什么？怎么样？</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>在介绍 SpringBoot 之前我们首先来简单介绍一下 Spring。Spring 是诞生于2002年的 Java 开发框架，可以说已经成为 Java 开发的事实标准。所谓事实标准就是虽然 Java 官方没有说它就是开发标准，但是在当前 Java 开发的众多项目中，当我们谈到产品级的 Java 项目的时候，大多都是基于 Spring 或者应用了 Spring 特性的。</p><p>Spring 基于 IOC 和 AOP 两个特性对 Java 开发本身进行了大大的简化。但是一个大型的项目需要集成很多其他组件，比如一个 WEB 项目，至少要集成 MVC 框架、Tomcat 这种 WEB 容器、日志框架、ORM框架，连接数据库要选择连接池吧……使用 Spring 的话每集成一个组件都要去先写它的配置文件，比较繁琐且容易出错。</p><p>然后就有了SpringBoot。</p><p>Spring Boot 是由 Pivotal 团队提供的全新框架，2014 年 4 月发布 Spring Boot 1.0 2018 年 3 月 Spring Boot 2.0发布。它是对spring的进一步封装，其设计目的是用来简化 Spring 应用的初始搭建以及开发过程。怎么简化的呢？就是通过封装、抽象、提供默认配置等方式让我们更容易使用。</p><p>SpringBoot 基于 Spring 开发。SpringBoot 本身并不提供 Spring 框架的核心特性以及扩展功能，也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p>关于 SpringBoot 有一句很出名的话就是<strong>约定大于配置</strong>。采用 Spring Boot 可以大大的简化开发模式，它集成了大量常用的第三方库配置，所有你想集成的常用框架，它都有对应的组件支持，例如 Redis、MongoDB、Jpa、kafka，Hakira 等等。SpringBoot 应用中这些第三方库几乎可以零配置地开箱即用，大部分的 SpringBoot 应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么会产生 SpringBoot 呢？</p><p>刚才说 SpringBoot 简化了基于 Spring 开发，这只是最直观的一方面，事实上 SpringBoot 的诞生有它所处的大时代背景这个原因在里面的，那就是微服务，这也是谈 SpringBoot 必谈微服务的原因。</p><img src="https://i.loli.net/2019/10/28/Qq9ywef6MlPEkCT.jpg" alt="martin_fowler.jpg" style="zoom:50%;" /><p>2014年一个叫 Martin Fowler （同时也是经典著作《重构：改善既有代码的设计》一书的作者）发表了一篇关于<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">微服务的博客</a>，比较形象生动地介绍了什么是微服务，然后微服务才慢慢被人所熟知。他说微服务其实是一种架构风格，我们在开发一个应用的时候这个应用应该是由一组小型服务组成，每个小型服务都运行在自己的进程内；小服务之间通过HTTP的方式进行互联互通。和微服务相对应的就是我们之前的，单体应用，就是大名鼎鼎的 all in one 的风格。这种风格把所有的东西都写在一个应用里面，比如我们熟悉的OA，CRM，ERP系统，所有的页面，所有的代码都放在一起，打成打成一个war包，然后把war包放在Tomcat容器中运行。</p><p><img src="https://i.loli.net/2019/10/28/DXS84IniF7YrKBW.png" alt="microservice.png"></p><p>这种传统web开发的架构模式当然也有它的优势，比如它测试部署比较简单，因为不涉及到多个服务的互联互调，只需要把一个包上传到服务器就行了，可以说是一人吃饱全家不饿。同样也不会给运维带来麻烦，方便水平扩展，只需要又把相同的应用复制多份放在不同的服务器中就达到了扩展的目的。</p><p>单体应用的的缺点也显而易见，容易牵一发而动全身，比如要更改一个小小的功能，就可能需要重新部署整个应用。当然，更大的挑战就是日益增长的用户需求。</p><h2 id="怎么样"><a href="#怎么样" class="headerlink" title="怎么样"></a>怎么样</h2><p>介绍了一大堆，那 SpringBoot 的开箱即用是怎么体现的呢。</p><p>SpringBoot 官方推荐的构建应用的方式是使用 <a href="https://start.spring.io/" target="_blank" rel="noopener">Spring Initializr</a>，直接在网页上选择好构建工具、语言、SpringBoot 版本，填好自己的项目名和初始依赖，然后点<strong>Generate</strong> 按钮，就能下载一个构建好的工程的zip包，只需要把这个包解压之后导入IDE就可以了。</p><p>这已经是一个包含依赖的、完整的、可独立运行的springboot应用了！你所需要做的就是往里面填充自己的业务代码！</p><p>当然，如果能直接使用IDE来进行上述操作可以让这个过程变得更顺滑。如果你使用的是 IDEA 商业版的话，新建工程的时候直接有 Spring 的选项；如果是IDEA社区版的话，可以安装 <code>Spring Assistant</code> 这个插件可以实现同样的功能。它们的原理是帮你把连接 <a href="https://start.spring.io/" target="_blank" rel="noopener">Spring Initializr</a> 并下载解压这个过程自动化了，所以只需要保持网络畅通就行了。</p><table><thead><tr><th align="center">SpringBoot</th><th align="center">Spring + Spring MVC</th></tr></thead><tbody><tr><td align="center"><a href="https://start.spring.io/" target="_blank" rel="noopener">Spring Initializr</a></td><td align="center">1. 安装Tomcat<br>2. 引入spring必要依赖<br>  spring-webmvc<br>spring-context<br>spring-beans<br>spring-aspects<br>…<br>3. 引入必要的第三方依赖，jdbc,test,log这些依赖依然要注意版本兼容问题<br>4. 新建webapp/WEB-INFO/web.xml<br>5. applicationContext.xml<br>6. Springmvc.xml<br>…</td></tr></tbody></table><p>那如果要用原生的springMVC来实现这个事情就复杂了，可以看看右边我大概罗列的这些步骤，当时学的时候让我我非常头疼。要单独安装Tomcat，安装的过程中要注意版本和当前的spring版本是否兼容，手动引入spring各个模块的依赖。pom.xml就不说了，maven工程都要用到，然后还有web.xml-用来配置servlet、拦截规则、字符编码器等等，applicationContext.xml，springmvc.xml 等一大堆xml文件……</p><p>这个过程对初学者非常不友好，记忆这些步骤和配置文件能让人崩溃，xml这种表达方式又不是很直观。这些东西称为脚手架，在小公司里面会搭建这些东西就可以算半个师傅了，小弟们就可以在搭好的架子里面写业务代码了。</p><p>再聊回微服务，试想一下，如果我们要跟上时代的步伐，使用微服务去开发软件，每个功能模块都部署成一个单独的服务，这个时候我们再使用纯粹的 Spring 去开发，每开发一个服务都需要重复的搭建项目骨架，然后编写各种配置文件，几十几百个服务加起来，这部分工作量是很大的，这还不算业务代码的开发时间。这种时候就是 SpringBoot 发挥它开箱即用的特质的时候了。然后多个微服务之间再通过 Spring 全家桶里面的 SpringCloud 进行管理，比如服务注册、服务发现等等。所以我们现在说 SpringBoot 是 Java 企业级开发的一站式解决方案。</p><p><img src="https://i.loli.net/2019/10/28/NDhQZmzAxLRMyjp.jpg" alt="整个世界清静了"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>软件工程是一个不断抽象，不断把复杂的东西简化的这样一套理论和工具，不是说使用起来越复杂就可以彰显我的高端和牛逼，有时候反而是做多错多。所以SpringBoot告诉我们这些工作都没必要，框架来做就行了，你们可以专注于代码逻辑。</p><p>SpringBoot 具有如下优点：</p><ul><li><p>快速创建独立运行的Spring项目以及与主流框架集成、</p></li><li><p>使用嵌入式的Servlet容器，应用无需打成WAR包</p></li><li><p>Starters自动依赖与版本控制</p></li><li><p>大量的自动配置，简化开发，也可修改默认值</p></li><li><p>无需配置XML，无代码生成，开箱即用</p></li><li><p>准生产环境的运行时应用监控</p></li><li><p>与云计算的天然集成</p></li></ul><p>这些优点这篇文章中有的涉及到了，有的还没介绍。我会在之后的文章中陆续把这些话题展开。那么现在，你要做的就是，赶紧把 SpringBoot 用起来吧！</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车站</title>
      <link href="/2019/10/25/che-zhan/"/>
      <url>/2019/10/25/che-zhan/</url>
      
        <content type="html"><![CDATA[<br /><center>三三两两的人</center><center>广告牌里的灯</center><center>影子被拉长，被冲淡</center><br /> <br /> <center>每刻都在擦肩而过</center><center>每天都有失之交臂</center><center>每个人和每个人都保持距离</center><br /> <br /> <center>心思先上路</center><center>第三个路口的便利店</center><center>蛋挞总也吃不腻</center><center>一会儿已经飞到终点</center><center>是目的地、家、或者怀里</center><br /> <br /> <center>也许把大脑放空</center><center>让眼神失去焦距</center><center>每一辆车过</center><center>都能撕出回到现实的间隙</center><center>然后带走一群秘密</center><center>带来一阵张望和匆匆离去</center><br /> <br /> <center>欸～</center><center>上车的乘客请注意</center><center>麻烦往后面挤一挤，挤一挤</center><p align="right">木白</p>            <p align="right">于2016年10月26日</p>            ]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
