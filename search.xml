<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重新开始</title>
      <link href="/2023/08/26/chong-xin-kai-shi/"/>
      <url>/2023/08/26/chong-xin-kai-shi/</url>
      
        <content type="html"><![CDATA[<p>我这个人，热情总是随着时间和外部的刺激此起彼伏。当对一个事情突然有了兴趣，就会茶饭不思的去调研、搜集资料、甚至动手操作一把，然后当取得阶段性的完成之后，这种“完成感”就会让热情迅速消退，刚刚完成的事情有可能好久都不会再碰、再提起，甚至一想到它就会在潜意识里面和那些遇到的困难联系起来：“当时搞得好复杂”，然后就会避免再重新拾起。</p><p>古人说三天打鱼两天晒网，我甚至三天打鱼三年晒网，不过这种描述在我这里好像也不够准确，我感觉有点像贤者时间，“完成”就是最后的高潮，然后就是无趣，甚至想睡觉。</p><p>搭建家庭影音中心如此，写博客亦是如此，最后一篇博客的更新是21年5月，已经两年多了，啊，岁月如梭！</p><p>这中间经历了疫情，换团队，离职……</p><p>最近因为工作的原因学了前端，加上本来写了几年后端，所以突然发现，我已经是具备交付一个完整的产品的能力了的人了。但是目前并不知道应该做啥。</p><p>然后前几天又加了一个副业群，看各路大佬各种分享自己的工具、产品、博客、课程，发现原来这么多人在坚持着自己的事情，然后内心的热情又开始被点燃–外部刺激果然有用。</p><p>眼花缭乱下，虽然依然还不知道如何下手，想起，我是有博客的人啊。</p><p>是啊，我至少还有博客。要不就从重新更新博客开始吧，与其马上想赚钱，不如先找到一点做事和坚持的感觉。</p><p>那就，开始吧？重新开始更新！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新部署hexo博客</title>
      <link href="/2023/08/26/chong-xin-bu-shu-hexo-bo-ke/"/>
      <url>/2023/08/26/chong-xin-bu-shu-hexo-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>我的博客是用<code>hexo</code>框架在之前公司的电脑搭建的，然后同步到<code>github page</code>并绑定自己域名实现访问。在我的印象中，github已经上已经有了，就不用担心丢失了。当我今天想着要重新在自己的电脑上部署原来的博客的时候才发现完全不是那么回事，github上的数据都是经过hexo解析过的，如果没有原始文件的话（md）,我就只有一堆HTML…</p><p>捣鼓了半天之后之后才想起，我可能在离职的时候把博客相关的原始数据从公司电脑搞出来了（红线操作了），然后去网盘上找到之后这事儿才算有眉目了，可以继续推进。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql:全局锁和表锁</title>
      <link href="/2021/05/23/mysql-quan-ju-suo-he-biao-suo/"/>
      <url>/2021/05/23/mysql-quan-ju-suo-he-biao-suo/</url>
      
        <content type="html"><![CDATA[<p>根据加锁的范围，MySQL 里面的锁大致可以分成<strong>全局锁、表级锁和行锁</strong>三类</p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对<strong>整个数据库实例</strong>加锁</p><pre class=" language-SQL"><code class="language-SQL">Flush tables with read lock (FTWRL)unlock tables // 解锁</code></pre><p>加锁之后整个库处于只读状态，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是，做全库逻辑备份</strong>。也就是把整库每个表都 select 出来存成文本。</p><p>但是就算是备份，使用这种锁整个实例的方式代价也很大。有没有更好的方式既能让备份过程中更新不影响视图的<strong>逻辑一致</strong>，又能不对整个实例加锁呢？</p><p>有，<strong>就是在可重复读隔离级别下开启一个事务</strong>。</p><p>官方自带的逻辑备份工具是 <strong>mysqldump</strong>。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL 里面表级别的锁有两种：一种是<strong>表锁</strong>，一种是<strong>元数据锁（meta data lock，MDL)</strong>。</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁的语法：</p><pre class=" language-SQL"><code class="language-SQL">lock tables … read/write;unlock tables;  -- 解锁</code></pre><p>既可以主动解锁也可以在客户端断开的时候自动释放锁。</p><p>read锁特性：</p><ul><li><p>read锁是共享锁，可以被多个会话持有；其他会话不获取锁也能读取数据</p></li><li><p>持有锁的会话只能读不能写，其他会话在锁被持有期间只能读，写会被被<strong>阻塞</strong></p></li><li><p>持有锁的会话不论是否正常终止，mysql都会隐式释放锁</p></li></ul><p>write锁特性：</p><ul><li><p>持有表锁的唯一会话可以从表读取和写入数据</p></li><li><p>在释放WRITE锁定之前，其他会话无法从表读取数据或将数据写入表</p></li></ul><h3 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h3><p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是保证读写的正确性。</p><p>当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p><p>读锁之间不互斥，读写锁之间、写锁之间是互斥的。</p><p>对表进行DDL的时候，比如你增加字段、修改字段，或者加索引，需要考虑两个方面，一是这种操作会<strong>扫描全表</strong>，二是它们会获取MDL写锁，并且事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放，可能会阻塞所有的增删改查操作。</p><p>在业务中安全的DDL一般要考虑两点：</p><ol><li><p>解决长事务，事务不提交，就会一直占着 MDL 锁，如果DDL过程中发现长事务要么kill掉，要么等该事务运行完再执行</p></li><li><p>对DDL操作加入超时</p></li></ol><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。InnoDB 是支持行锁的， 而MyISAM不支持。</p><h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a><strong>两阶段锁协议</strong></h3><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是<strong>两阶段锁协议</strong>。</p><p>这意味着，如果在同一个事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>如果并发的不同线程都在彼此等待某临界资源，就可能导致<strong>死锁</strong>。这种时候通常有两个策略：</p><ol><li><p><strong>等待+超时</strong>，超时可以通过参数innodb_lock_wait_timeout 来设置，innodb该值的默认值是50s；</p></li><li><p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p></li></ol><p>由于超时时间不好把握，太长业务不能接受，太短容易误伤，所以通常使用<strong>策略二</strong>。</p><p>死锁检测也是有额外负担的：<strong>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁</strong>，这是一个时间复杂度是 O(n) 的操作（检测其他所有线程的所持有情况）。当出现<strong>热点行更新</strong>的时候，大量的死锁检测可能导致CPU利用率很高，但是却执行不了几个事务的情况。</p><p><strong>这就引出了怎么解决由这种热点行更新导致的性能问题</strong>？</p><ol><li><p>如果确保业务不会出现死锁，可临时把死锁检测关掉，但是有风险；</p></li><li><p><strong>控制并发度</strong>。两个方法，一是通过代码控制，从客户端或者mysql源代码端控制，对热点更新进行限流或者排队；二是<strong>一行改成逻辑上的多行</strong>来减少锁冲突。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea中使用gradle编译spring源码</title>
      <link href="/2020/12/18/idea-zhong-shi-yong-gradle-bian-yi-spring-yuan-ma/"/>
      <url>/2020/12/18/idea-zhong-shi-yong-gradle-bian-yi-spring-yuan-ma/</url>
      
        <content type="html"><![CDATA[<p>废话少说，直接进入正题！</p><h2 id="一、下载及预编译"><a href="#一、下载及预编译" class="headerlink" title="一、下载及预编译"></a>一、下载及预编译</h2><p>首先git clone源码到本地：</p><pre class=" language-Bash"><code class="language-Bash">https://github.com/spring-projects/spring-framework.git </code></pre><p>代码clone到本地之后进入到文件件中<code>cd spring-framework</code>，这个时候需要关注<a href="http://import-into-idea.md" target="_blank" rel="noopener"><code>import-into-idea.md</code></a>这个文件，这是用idea编译源码的说明文件。根据里面的说明，在编译整个源码前需要预先编译<code>spring-oxm</code>和<code>spring-core</code>这两个模块，依次运行命令<code>./gradlew :spring-core:compileTestJava</code>和<code>./gradlew :spring-oxm:compileTestJava</code> 。编译过程如下，当然首先是安装好gradle：</p><pre class=" language-Bash"><code class="language-Bash">$ ./gradlew :spring-oxm:compileTestJavaWelcome to Gradle 6.7.1!Here are the highlights of this release: - File system watching is ready for production use - Declare the version of Java your build requires - Java 15 supportFor more details see https://docs.gradle.org/6.7.1/release-notes.htmlStarting a Gradle Daemon, 1 busy Daemon could not be reused, use --status for details> Task :spring-oxm:genJaxb[ant:javac] : warning: 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false for repeatable buildsDeprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.Use '--warning-mode all' to show the individual deprecation warnings.See https://docs.gradle.org/6.7.1/userguide/command_line_interface.html#sec:command_line_warningsBUILD SUCCESSFUL in 37s40 actionable tasks: 24 executed, 16 from cache# pengchengbai @ Pengcheng-Bai in ~/IdeaProjects/spring-framework on git:master o [11:42:36]$ ./gradlew :spring-core:compileTestJavaDeprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.Use '--warning-mode all' to show the individual deprecation warnings.See https://docs.gradle.org/6.7.1/userguide/command_line_interface.html#sec:command_line_warningsBUILD SUCCESSFUL in 7s17 actionable tasks: 2 from cache, 15 up-to-date</code></pre><h2 id="二、导入Idea并编译"><a href="#二、导入Idea并编译" class="headerlink" title="二、导入Idea并编译"></a>二、导入Idea并编译</h2><ol><li><p>使用Idea导入源码：File -&gt; New -&gt; Project from Existing Souces…然后选择我们的<code>spring-framework</code>目录就行了 注意这里是选择New 而不是Open；</p></li><li><p>然后在Import Project 面板中选择gradle，点击Finish；</p></li><li><p>可以发现IDEA会自动开始构建编译spring源码。 </p></li></ol><h2 id="三、验证"><a href="#三、验证" class="headerlink" title="三、验证"></a>三、验证</h2><p>编译好源码之后怎么验证构建和编译是否成功呢？我们可以自己写一段代码，然后依赖我们构建的源码，如果能够正常运行，则说明构建成功。</p><ol><li><p>在spring-framework项目下新建一个module，在新建的时候gradle构建（当然maven也可以，这里只是为了跟源码保持统一），然后Module SDK选择Java8；</p></li><li><p>然后在路径<code>src/main/java</code>中创建包和源代码，我这里创建了一个配置类：</p></li></ol><pre class=" language-Java"><code class="language-Java">package site.pengcheng;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;/** * @author pengchengbai * @description * @date 2020/12/18 11:50 上午 */@Configuration@ComponentScan("site.pengcheng")public class AppConfig {} </code></pre><p>然后再创建一个普通的<code>spring Bean</code>：</p><pre class=" language-Java"><code class="language-Java">package site.pengcheng.pojo;import org.springframework.stereotype.Component;/** * @author pengchengbai * @description * @date 2020/12/18 11:51 上午 */@Componentpublic class Hello {  public void hello(){    System.out.println("Hello, world");  }} </code></pre><p>最后创建一个测试类：</p><pre class=" language-Java"><code class="language-Java">package site.pengcheng;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import site.pengcheng.pojo.Hello;/** * @author pengchengbai * @description * @date 2020/12/18 11:52 上午 */public class TestHello {  public static void main(String[] args) {    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);    Hello bean = ac.getBean(Hello.class);    bean.hello();  }}</code></pre><p>这里使用<code>AnnotationConfigApplicationContext</code>作为spring上线文去获取bean，并运行bean中的方法。运行main方法，如果输出如下信息则表示成功：</p><pre class=" language-Java"><code class="language-Java">3:04:34 下午: Executing task 'TestHello.main()'...Starting Gradle Daemon...Gradle Daemon started in 1 s 577 ms> Task :buildSrc:compileJava UP-TO-DATE> Task :buildSrc:compileGroovy NO-SOURCE> Task :buildSrc:pluginDescriptors UP-TO-DATE...// 省略> Task :spring-context:jar UP-TO-DATE> Task :spring-study:compileJava> Task :spring-study:classes> Task :spring-study:TestHello.main()Hello, worldDeprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.Use '--warning-mode all' to show the individual deprecation warnings.See https://docs.gradle.org/6.7.1/userguide/command_line_interface.html#sec:command_line_warningsBUILD SUCCESSFUL in 16s35 actionable tasks: 2 executed, 33 up-to-date3:04:51 下午: Task execution finished 'TestHello.main()'.</code></pre><ol><li>最后就可以在spring的源码海洋中恣意畅游啦！</li></ol><h2 id="四、后记"><a href="#四、后记" class="headerlink" title="四、后记"></a>四、后记</h2><p>在这个过程中可能会遇到各种各样的报错，要么是idea版本问题，要么是gradle版本问题，要么是kotlin版本问题，还有的报错根本不知道什么问题。我这里只是记录了成功编译的那次的情况，仅做参考，遇到具体的问题还得具体解决，如果不想知道错误原因就卸载、删除、推翻重来！总会成功的！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>再谈Java中的四种引用</title>
      <link href="/2020/08/09/zai-tan-java-zhong-de-si-chong-yin-yong/"/>
      <url>/2020/08/09/zai-tan-java-zhong-de-si-chong-yin-yong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pengcheng.site/2020/01/31/java-qiang-ruo-ruan-xu-si-chong-yin-yong/">Java强、弱、软、虚四种引用</a>一文大体介绍了Java的四种引用，但是比较简单。这篇文章我们通过实际的例子来展示各种引用的用法。</p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用就是我们平时用来指向<code>new</code>创建的对象的最普通的引用:<code>Object o = new Object()</code>。</p><pre class=" language-mermaid"><code class="language-mermaid">graph LRA((o)) -->B(Object)</code></pre><p>如果一个对象有强引用指着，那么垃圾回收器是无论如何都不能回收它的。如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了。</p><p>为了更好地描述，我们准备一个<code>M</code>对象，并复写根对象<code>Object</code>中的<code>finalize</code>方法。如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">M</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finalize"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><code>finalize</code>方法会在垃圾回收器回收该对象<strong>之前</strong>被调用，所以我们可以在它里面打印日志来追踪对象是否被被回收。它早期的主要设计目的是在对象从内存中删除之前释放它们使用的资源。但是在实际中，gc什么时候调用<code>finalizer</code>取决于JVM的具体实现和系统的具体情况，甚至不一定会被调用，所以我们不能依赖于该方法来清理资源，它适合做的关闭资源等工作<code>try-catch-finally</code>也能做，这也是该方法为什么被标记为<code>@Deprecated</code>的原因。</p></blockquote><p>接下来我们就可以测试强引用的回收了：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NormalReferenceTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        M m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> null<span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行该程序就能看到控制台打印<code>finalize</code>.</p><p>该程序先把M对象new出来用引用m指向它，然后把<code>m=null</code>之后，对象M就失去了引用，也就是说可以被垃圾回收了。为了”立即”进行垃圾回收，我们调用了<code>System.gc()</code>。并且为了看到打印结果，我们在最后写了一个<code>System.in.read()</code>用来阻塞main线程，不让其结束，因为回收垃圾不是在main线程里面进行的，而是在单独的线程中, 所以需要这样一个方法来等待垃圾回收线程运行，才能看到结果的打印。</p><blockquote><p>在实际应用中，坚决不要显式调用<code>System.gc()</code>，原因如下：</p><ol><li>其开销很大</li><li>它并不能立即触发垃圾回收，只是个JVM一个垃圾回收的提示</li><li>对于何时需要调用GC，其实JVM自己更清楚</li></ol><p>所以在jvm参数中有-XX:+DisableExplicitGC，这个参数作用是禁止代码中显式调用<code>System.gc()</code>，使得代码中调用System.gc()没有任何效果。</p></blockquote><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>只有在空间不够的时候，软引用指向的对象才会被回收。下面用demo掩饰一下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SoftReferenceTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SoftReference<span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 2</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol><li>首先给软引用指向的byte数组分配10M空间</li><li>调用<code>System.gc()</code>并给gc一点回收时间</li><li>再分配一个15M的强引用数组</li></ol><p>用jvm参数<code>-Xmx20M</code>启动该程序之后输出如下：</p><pre><code>[B@7a0ac6e3[B@7a0ac6e3null</code></pre><p>可以看到前两次都能正常获取到软引用指向的对象，但是当分配了另一个强应用byte数组之后，heap将装不下，这时候系统会进行垃圾回收，先回收一次，如果不够，会把软引用干掉。那么最后再去获取的时候就是null了。</p><p>软应用这种特性通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。比如大对象的缓存。在著名的<code>guava</code>缓存框架中，提供了<code>softValues</code>作为软引用的相关实现：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenSoftValue_thenRemoveFromCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    CacheLoader<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> loader<span class="token punctuation">;</span>    loader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CacheLoader</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> String <span class="token function">load</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> key<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    LoadingCache<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> cache<span class="token punctuation">;</span>    cache <span class="token operator">=</span> CacheBuilder<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">softValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>loader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用就是在遇到GC的时候直接被回收的。我们可以很容易的模拟出它这种特性，运行如下代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeakReferenceTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        WeakReference<span class="token operator">&lt;</span>M<span class="token operator">></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">site<span class="token punctuation">.</span>pengcheng<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>reference<span class="token punctuation">.</span>M<span class="token annotation punctuation">@71be98f5</span>nullfinalize</code></pre><p>可以看到GC之后就不能拿到原对象了。</p><p>这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</p><h3 id="弱引用在Threadlocal中的应用"><a href="#弱引用在Threadlocal中的应用" class="headerlink" title="弱引用在Threadlocal中的应用"></a>弱引用在Threadlocal中的应用</h3><p>在jdk中有一个很重要的地方用到了<code>WeakReference</code>，那就是<code>ThreadLocal</code>。<code>ThreadLocal</code>在调用<code>set</code>方法保存<code>value</code>的时候会取出<strong>当前线程</strong>中的<code>ThreadLocal.ThreadLocalMap</code>对象，然后把自己（this，ThreadLocal对象本身）作为<code>key</code>，保存的数据作为value，封装成一个<code>ThreadLocal.ThreadLocalMap.Entry</code>对象，而这个<code>Entry</code>类就是一个<code>WeakReference</code>的子类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span></code></pre><p>之所以使用<code>WeakReference</code>，是为了防止内存泄露（具体原因请查阅相关资料）。</p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用又被称为幻象引用，通过该引用不能得到被其包装的原对象（总是返回null）。虚引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的<strong>机制</strong>。这个机制需要通过<code>ReferenceQueue</code>来配合实现，比如原对象被回收之后，发送一个通知到<code>ReferenceQueue</code>中，然后消费这个队列的用户就能知道虚引用的对象被回收了，然后可以做一些相应的事情。</p><p>考虑如下代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PhantomReferenceTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> LIST <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ReferenceQueue<span class="token operator">&lt;</span>M<span class="token operator">></span> QUEUE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        PhantomReference<span class="token operator">&lt;</span>M<span class="token operator">></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>phantomReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                LIST<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1014</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>phantomReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 模拟监控线程，监控对象是否被会后</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Reference<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">M</span><span class="token operator">></span> poll <span class="token operator">=</span> QUEUE<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>poll <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"虚引用被jvm回收了"</span> <span class="token operator">+</span> poll<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>使用<code>-Xmx10M</code>参数运行这段代码输出：</p><pre><code>nullnullnullnullnullfinalizenull虚引用被jvm回收了java.lang.ref.PhantomReference@2cf96e41nullException in thread &quot;Thread-0&quot; java.lang.OutOfMemoryError: Java heap space</code></pre><p>我们先生成一个包装了M对象的虚引用，然后疯狂生成byte数组来挤占对空间；当内存不够的时候，M对象被回收，然后另一个通过<code>ReferenceQueue</code>·队列监控M对象是否被回收的线程就收到了通知并通过打印展示了出来。</p><p>虚引用在实际中一个重要的应用就是<strong>管理堆外内存</strong>。</p><p>原来在读取外部文件的时候数据需要通过操作系统内核，然后到操作系统管理的内存，然后再被拷贝到jvm管理的内存中，这个拷贝过程会影响程序性能。所以Java引入了堆外内存，可以用一个<strong>jvm中的引用</strong>直接指向堆外的内存，减少数据拷贝，这个技术称为<strong>零拷贝(zero copy)</strong>。<code>DirectByteBuffer</code>就使用了堆外内存：</p><pre class=" language-java"><code class="language-java">ByteBuffer bb <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这句代码表示用一个堆内的引用<code>bb</code>指向一个堆外的、大小为1M的内存。</p><p>但是堆外内存不归GC管，也就是不归jvm管（而是归Hotspot的c++程序管），所以就没办法知道什么时候该回收。这种时候虚引用就派上了用场：用虚引用包装<code>DirectByteBuffer</code>对象，当这个对象被回收的时候<code>ReferenceQueue</code>会收到通知，告诉jvm有堆外内存需要被处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们知道GC是通过可达性分析判断一个对象是否应该回收的，而上述的各种引用在可达性分析中扮演了十分重要的角色。</p><p>上述的各种引用<code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>都是<code>java.lang.ref.Reference</code>的子类。它们有两个重要的特征：</p><ol><li>提供<code>public T get()</code>方法获取原有对象（虚引用该方法返回null）</li><li>都有一个需要<code>ReferenceQueue</code>作为参数的构造方法</li></ol><p>其中1意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态！</p><p>在虚引用中我们已经使用过了<code>ReferenceQueue</code>，因为它不能get出原对象，那么对<code>ReferenceQueue</code>的使用就成了其唯一的使用方式。事实上软引用和弱引用也可以关联到<code>ReferenceQueue</code>，从而实现这样的逻辑：JVM 会在特定时机将引用 enqueue 到队列里，我们可以从队列里获取引用（remove 方法在这里实际是有获取的意思）进行相关后续逻辑：</p><pre class=" language-java"><code class="language-java">Object counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ReferenceQueue refQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PhantomReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>counter<span class="token punctuation">,</span> refQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>counter <span class="token operator">=</span> null<span class="token punctuation">;</span>System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Remove是一个阻塞方法，可以指定timeout，或者选择一直阻塞</span>    Reference<span class="token operator">&lt;</span>Object<span class="token operator">></span> ref <span class="token operator">=</span> refQueue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ref <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do something</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Handle it</span><span class="token punctuation">}</span></code></pre><p>本文相关代码可以在<a href="https://github.com/mooba/learnconcurrency/tree/master/src/main/java/site/pengcheng/jvm/reference" target="_blank" rel="noopener">这里</a>找到。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> — Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程：用Lock接口自定义同步组件</title>
      <link href="/2020/05/24/java-bing-fa-bian-cheng-yong-lock-jie-kou-zi-ding-yi-tong-bu-zu-jian/"/>
      <url>/2020/05/24/java-bing-fa-bian-cheng-yong-lock-jie-kou-zi-ding-yi-tong-bu-zu-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文将简单介绍<code>Lock</code>接口和<code>AbstractQueuedSynchronizer</code>同步器，并基于它们两个实现一个取名为互斥锁的同步组件</p><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>在Java SE 5之后并发包中提供了<code>Lock</code>接口来实现同步组件，当然也能够实现锁，因为锁是一种特定的同步组件。它实现的锁能够提供和<code>Synchronized</code>的类似的同步功能并且拥有更多的灵活性。这些灵活性主要表现在一下三个方面：</p><ol><li>可以尝试非阻塞地获取锁：<code>tryLock()</code>相关方法没有获取到锁能够理解返回而不是阻塞等待</li><li>能被中断地获取锁：获取到锁的线程能够响应中断，中断时中断异常抛出并且锁释放</li><li>超时获取锁：如果指定时间内没有获取到锁则返回</li></ol><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><p>队列同步器<code>AbstractQueuedSynchronizer</code>（AQS，简称同步器）是用来构建同步组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。<br>同步器的设计是基于<strong>模板方法模式</strong>的。定义同步器时，我们可以通过继承AQS来实现。AQS是一个抽象类，其中我们需要关注的方法方法可大致分为3类：</p><ol><li>访问或修改同步状态的3个方法，分别是：<ul><li><code>getState()</code>：获取当前同步状态</li><li><code>setState(int newState)</code>: 设置当前同步状态</li><li><code>compareAndSetState(int expect, int update)</code>: 使用CAS原子地设置当前状态</li></ul></li><li>可以在子类中重写的方法;</li><li>定义好的模板方法，这些模板方法会调用2中重写好的方法，它们基本也可以分为三类：<ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中的等待线程情况</li></ul></li></ol><h2 id="自定义同步组件"><a href="#自定义同步组件" class="headerlink" title="自定义同步组件"></a>自定义同步组件</h2><p>有了上面两方面的基础知识，我们就可以自定义同步组件了。<br>自定义同步组件就是写一个<code>Lock</code>接口的实现类，该实现基本都是通过聚合一个<strong>同步器的子类</strong>来完成线程访问控制的。而同步器的子类推荐被定义为同步组件的静态内部类。<br>下面自定义了一个“独占锁”的同步组件，其目的是同一个时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待。代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> site<span class="token punctuation">.</span>pengcheng<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>AbstractQueuedSynchronizer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Condition<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Lock<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author pengchengbai * @description * @date 2020/5/24 11:35 上午 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mutex</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 是否处于占用状态</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 当状态为0的时候获取锁</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 释放锁，将状态设置为0</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 下面的方法表示将同步组件的操作代理给自定义同步器Sync     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Sync sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回一个Condition，每个condition都包含了一个condition队列</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过这个示例可以看出，当用户使用独占锁这个同步组件的时候，并不会直接和内部的同步器打交道，而是使用Mutex提供的方法（Lock中定义方法）。之前也说到，AQS是用来构建同步组件的基础框架，它们这种“合作”方式可以大大降低实现一个自定义同步组件的门槛。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同步器是实现同步组件的关键。通过聚合同步器实现同步组件的时候，内部利用了同步器实现具体语义，对使用者隔离了实现细节。可以这样理解，同步组件（比如锁）是面向使用者的，它定义了使用者与其交互的接口，屏蔽了具体实现；同步器是面向同步组件的，它屏蔽了同步状态管理、线程排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java,juc,concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDIA学习笔记</title>
      <link href="/2020/02/29/ddia-xue-xi-bi-ji-ch1-ke-kuo-zhan-yu-ke-wei-hu-de-ying-yong-xi-tong/"/>
      <url>/2020/02/29/ddia-xue-xi-bi-ji-ch1-ke-kuo-zhan-yu-ke-wei-hu-de-ying-yong-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>第一章其实是个简介、大纲性质的章节，主要是介绍可靠性、可扩展性、可维护性的概念，这也是我们设计和维护系统的时候总是会面对的概念，它们穿插在整本书中。本章在介绍这些概念的时候很多地方也是以列举一条条更细的概念来展开的。如果完全按照他的内容来来写就会变成照搬，所以我会加一点扩展和我在实际工作中遇到的情况。</p><h2 id="认识数据系统"><a href="#认识数据系统" class="headerlink" title="认识数据系统"></a>认识数据系统</h2><h3 id="数据系统的分类"><a href="#数据系统的分类" class="headerlink" title="数据系统的分类"></a>数据系统的分类</h3><p>从负载类型来区分的话，数据系统可以分为两种典型的负载类型，<strong>数据密集型</strong>和<strong>计算密集型</strong>。</p><p>其中数据密集型以大数据相关技术为代表，最有名的就是Hadoop生态的各种组件，如用于数据存储的 HDFS</p><p>、HBASE，用于数据批处理的 MapReduce 和 Spark，用于流式处理的 Storm、Spark Streaming。从这些组件的功能就可以看出，数据密集型主要关注的是用分布式系统来<strong>存储</strong>和<strong>处理</strong>数据。</p><p>计算密集型以目前非常火的深度学习为代表，因为深度学习模型中的网状模型的训练需要大量的输入和待学习参数，学习过程中每一次正向传播和反向传播更新的参数量可能是百万、千万甚至亿级别的，需要大量的计算量，这些计算大多是矩阵计算，所以 GPU 比 CPU 更擅长这种运算。</p><p>当然这种分类只是从负载类型来看，在实际应用中这两者其实没有那么明显的界限。深度学习可以看成是大数据的上层应用，依赖数据处理系统进行数据存储、数据清洗、特征工程等。他们都属于数据系统，但是本书主要关注的是前者，也就是数据密集型系统设计。</p><h3 id="数据系统的组成"><a href="#数据系统的组成" class="headerlink" title="数据系统的组成"></a>数据系统的组成</h3><img src="https://i.loli.net/2020/02/29/JwaouRBLNnDvfxS.png" alt="数据系统架构图" style="zoom:150%;" /><p>这是书中给出的一张数据系统的架构图，其实如果做过 web 服务的可能会对它感到亲切，就是一个简单的网站的后端架构图，或者说更通用一点，是基于 request 和 response 提供服务的这样一个应用。</p><p>客户端调用到达之后，如果是<strong>读</strong>请求，则先访问内存中的缓存数据，如果缓存中没有命中则需要击穿到“主数据库”中取数，然后再通过应用代码把数据更新到缓存中；如果是<strong>写</strong>数据，则先写“主数据库”，然后再把数据更新到缓存中。这也是网站最基本的处理流程和相关组件。</p><p>如果有搜索请求，则应用代码会到全文索引数据库中查找，比如我们熟悉的 ElasticSearch。</p><p>对于不需要马上响应或者马上执行的任务（比如图中发邮件的例子），可以先把请求放到消息队列中，然后由其他的线程或者进程从队列中把消息拿出来然后异步地处理掉。</p><p>在这张架构图中涉及到的数据组件有，数据库(database)、缓存(cache) 、流式处理(stream processing)、批处理(batch processing)。这些组件在有一定数据量的服务中还是比较常见的。并且在图中每个组件都是以单点的形式在图中展现的，在实际应用中往往会更加复杂，图中的每个组件节点都可能是一个集群。还有一些属于数据密集型应用的组件并没有在图中得到展现，比如围绕hadooop生态链的批处理工具。</p><p>整本书也是围绕着这些组件的发展、应用、原理以及组件与组件之间的交互来展开的。</p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><h3 id="对软件的期望"><a href="#对软件的期望" class="headerlink" title="对软件的期望"></a>对软件的期望</h3><p>软件作为工具，我们就会对这些工具有着特定的期望。典型的期望如下：</p><ul><li>应用程序表现出用户所期望的功能<br>这是对软件作为工具最基本的要求，是锤子至少得能敲东西，是钉子至少得能钉东西是吧。</li><li>允许用户犯错，允许用户以出乎意料的方式使用软件<br>所谓出乎意料的方式，就是指没有在PRD、设计文档、用户使用手册上出现的操作。当用户出现这些操作的时候，至少要保证服务不能崩吧，如果能有错误提示信息甚至在用户出错之后能够引导用户进行正确操作就更好了。 最简单的例子就是参数校验，不让错误的请求流向应用更深层次的地方；还举个例子就是使用预编译的SQL语句，防止注入攻击等，在Java中通常框架已经帮我们做了。</li><li>在预期的负载和数据量下，性能满足要求<br>在电商网站中，如“双十一”、“双十二”这种大促的时候，网站流量会成倍地增加。而高并发的请求往往是网站性能的大杀器。这就要求我们在设计网站的时候就要考虑这种问题，也就是设计负载要远远大于平时的实际负载，并且在大流量到来之前通过压测、模拟和软硬件的扩容来合理应对。</li><li>系统能防止未经授权的访问和滥用<br>这就要靠系统的认证（Authentication）授权（Authorization）模块了。这两者的区别可以简单类比为，认证就是“证明你是你”；授权则是告诉你可以访问哪些模块。</li></ul><p>当软件对这些期望满足得越多，则说明该软件越“可靠”。</p><h3 id="硬件可靠性"><a href="#硬件可靠性" class="headerlink" title="硬件可靠性"></a>硬件可靠性</h3><p>硬盘崩溃、内存出错、机房断电、拔错网线……这些都是属于硬件可靠性的范畴。通常的做法就是提供“冗余”。磁盘阵列（RAID）、热插拔内存、备用电源或者发电机等都这这种“冗余”的具体体现。</p><h3 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h3><p>在对软件的期望小节中，我们谈到软件可靠性的表现形式。而在上面的数据应用架构图中，数据可能流经的每一个分支、每一个组件都会面临可靠性的挑战，尤其是在负载变高的情况下。那么要怎么实现可靠性呢。<br>对于 <em>Application Code</em> 来说保证可靠性的方式就是避免单点。避免单点的方式又分为横向扩展和纵向拆分。所谓横向扩展，就是把同一套代码部署在多个服务器中，然后用负载均衡把客户端的请求分散到各个服务中，降低单个服务的压力。纵向拆分就是把同一个请求路径上的不同软件模块部署到不同的服务器中，然后服务与服务之间的请求在用HTTP或者rpc串联起来。比如在Java中，就可以把经典的三层结构Controller、Service、和DAO层作为独立的服务部署，这也正是微服务的思想。<br>对于数据库来说，想要提高性能常用的方式包括：优化SQL、增加索引、分库分表、读写分离。在高并发场景中，数据库的选型已经数据模型的选项变得至关重要。在跟我们公司的DBA沟通的时候，对于不同的请求量（QPS），他给出一些比较有参考价值的选型建议：</p><ul><li><p>QPS 1-9k，直接用mysql就能搞定;</p></li><li><p>10k以上的写入QPS，mysql就需要考虑分库分表；</p></li><li><p>几十k的情况下，也可以考虑TiDB这种NewSql，我们之前在实际工作中压测过 TIDB，水平大概就处于这样一个水平；</p></li><li><p>100k以上， mysql 分库分表资源消耗很大，性价比变低，TiDB 同样已经比较吃力，可以考虑使用考虑 kv 存储这种 Nosql。</p></li></ul><p>Kv存储的话，也有两条路线，一条就是有钱就上 redis，因为是内存，比较贵，DBA那边的观点是几十几百个G还能忍，太多就不行，太伤钱了得评估性价比；另外一条就是用 pika 或者 MongoDB 这种分布式 kv 存储，然后再用 SSD 进行支撑。</p><p>除了QPS，也可以根据响应时间（P99）作数据库选型：</p><ul><li><p>如果使用TiDB，必须将预期响应时间定为100毫秒以上</p></li><li><p>对mysql进行小心设计和表结构优化，P99预期可以做到10毫秒以内</p></li><li><p>需要毫秒级别的响应只能上 redis 这种内存数据库</p></li></ul><p>这里我们较为详细讨论的应用层代码和数据库，但是事实上，图中画出的每一个组件，以及在软件构建过程中引入到系统中的每一个组件，都需要考虑可靠性问题。只有这样我们才能说，整个系统是可靠的。</p><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>可扩展性意味着，如果系统以某种方式增长，我们应对增长的措施有哪些。</p><p>书中举了 twitter 用户发布推文的例子，还是挺有代表性的。我们可以把它想象成微博，可以进一步想到每次各路明星爆出大瓜都对微博来说都是一次巨大的挑战，而技术就是在这种挑战中不断进步的。</p><h3 id="人为错误"><a href="#人为错误" class="headerlink" title="人为错误"></a>人为错误</h3><p>这部分其实总结一下就是–<strong>人是不可靠的</strong>。首先要承认人类这个感性、主观的物种的不可靠，然后才会想办法去规避这些不可靠带来的麻烦。这也正是我们在软件的生命周期中引入各种操作来避免这种不可靠的原因，包括设计文档、流程规范、代码审核、代码测试、技术运维……</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是《数据密集型应用系统设计》的第一篇读书笔记，主要是对全书的主角——“数据系统”——有个大概的认识。全篇比较偏科普性质，而且之前在组内有过相关分享，所以写起来比较顺手。以后也不知道能不能坚持写这本书的读书笔记，所以说不定是最后一篇呢，毕竟你永远也不知道自己能懒到什么程度。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>《数据密集型应用系统设计》</li><li><a href="https://mp.weixin.qq.com/s/m6jD0oB0sIHpH1z2gc3pew" target="_blank" rel="noopener">Shopee 的分布式数据库实践之路</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java强、弱、软、虚四种引用</title>
      <link href="/2020/01/31/java-qiang-ruo-ruan-xu-si-chong-yin-yong/"/>
      <url>/2020/01/31/java-qiang-ruo-ruan-xu-si-chong-yin-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>在Java中类型可分为两大类：<strong>值类型</strong>与<strong>引用类型</strong>。值类型就是基本数据类型（如int ,double 等），而引用类型,是指除了基本的变量类型之外的所有类型（如通过 class 定义的类型）。值类型只有一块存储空间，分配在 stack中，而引用类型有两块存储空间，存储引用的空间分配在 stack 上，存储引用所指向的对象空间分配在 heap 中，引用中保存了对象在 heap 中的地址。<br><img src="https://i.loli.net/2020/01/31/dfXcKznwkNvjQ5D.png" alt="java类型的内存表示"></p><h2 id="对象的传参方式"><a href="#对象的传参方式" class="headerlink" title="对象的传参方式"></a>对象的传参方式</h2><p>首选，这里所说的对象包括了<strong>基本数据类型</strong>和<strong>自定义数据类型</strong>（类），因为 java 中一切皆对象。</p><p>当把对象作为参数传递给函数后，函数对形参的更改会不会影响原对象呢？这个问题就引出了 java 是“值传递”还是“引用传递”的问题。</p><p>考虑下面的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">referenceTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//交换两个变量的值</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">int</span> c<span class="token operator">=</span>a<span class="token punctuation">;</span>       a<span class="token operator">=</span>b<span class="token punctuation">;</span>       b<span class="token operator">=</span>c<span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a: "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b: "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">int</span> c<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> d<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>       <span class="token function">Swap</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After Swap:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"c: "</span><span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"d: "</span><span class="token operator">+</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>a: 20b: 10After Swap:c: 10d: 20</code></pre><p>Swap 对形参的改变并没有改变传入的实参，所以这里是按<strong>“值传递”</strong>的。</p><p>事实上，从上面的图中可以看出，java 中<strong>基本数据类型</strong>在参数传递的时候是传入的原参数的一个拷贝，函数内部的改变只会改变拷贝值而不会改变原值。而自定义数据类型则不同。从图中可以看出，传参的时候，对引用进行了拷贝传入函数，但是引用指向的却是原来的对象，这个时候如果在函数中对对象进行更改则会影响函数外面的对象，所以这里可以说是<strong>“引用传递”</strong>。</p><p>回到上面的代码，如果我们真的想通过一个函数交换两个基本类型的值应该怎么办呢？两个方法：</p><ol><li>把所有变量封装到类中去</li><li>通过数组可以方便的实现值类型的数据源的交换</li></ol><h2 id="java中的四种引用类型"><a href="#java中的四种引用类型" class="headerlink" title="java中的四种引用类型"></a>java中的四种引用类型</h2><p>分别是指强引用、软引用、弱引用和虚引用</p><h3 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h3><p>强引用就是普通引用，也是平时使用最多的一种引用方式。只要某个对象有强引用与之关联，在内存不足的情况下，JVM 宁愿抛出<code>OutOfMemory</code>错误也不会回收这种对象。</p><h3 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h3><p>Java 中用<code>java.lang.ref.SoftReference</code>类来表示软引用。对于软引用关联着的对象，只有在内存不足的时候  JVM 才会回收该对象。</p><pre class=" language-java"><code class="language-java">SoftReference<span class="token operator">&lt;</span>String<span class="token operator">></span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中<code>get</code>方法用来获取与软引用关联的对象的引用，如果该对象被回收了，则返回 <code>null</code>。</p><p>软引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果软引用所引用的对象被 JVM 回收，这个软引用就会被加入到与之关联的引用队列中</p><p><strong>应用场景</strong>： 软引用通常用来实现<strong>内存敏感的缓存</strong></p><h3 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h3><p>java中，用<code>java.lang.ref.WeakReference</code>类来表示弱引用，它用来描述非必需对象的，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。<br>弱引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果弱引用所引用的对象被 JVM 回收，这个软引用就会被加入到与之关联的引用队列中</p><p><strong>应用场景</strong>： 弱引用同样通常用来实现内存敏感的缓存。</p><h3 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h3><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在 java 中用<code>java.lang.ref.PhantomReference</code>类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用<strong>必须</strong>和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p><strong>应用场景</strong>：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂springboot定时任务</title>
      <link href="/2019/12/30/yi-wen-gao-dong-springboot-ding-shi-ren-wu/"/>
      <url>/2019/12/30/yi-wen-gao-dong-springboot-ding-shi-ren-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在springboot中自带了一个轻量级的调度系统。如果我们希望在特定的时间或者以特定的时间间隔完成某些任务，那么它完全能够满足需求，不需要再额外引入像<code>Quartz</code>这种略显沉重的调度框架。下面我们就来介绍springboot中<code>@scheduled</code> 注解的用法。</p><blockquote><p>环境：springboot 2.2.2</p></blockquote><h2 id="常用简单定时任务"><a href="#常用简单定时任务" class="headerlink" title="常用简单定时任务"></a>常用简单定时任务</h2><p>首先，为了使用springboot中的定时任务，需要在springboot应用中加入 <code>@EnableScheduling</code> 注解。该注解开启对定时任务的支持，而且确保使用<strong>单线程</strong>创建任务执行器（task executor）:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableScheduling</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringbootSchedulerApplication</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringbootSchedulerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后我们就可以在一个被 <code>@Component</code> 标注的类（表示被纳入spring的管理）中加入我们的需要调度的任务：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScheduledTask</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> DateTimeFormatter dateTimeFormatter <span class="token operator">=</span> DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithFixedDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithInitialDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithCronExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面来具体看看它支持的各种类型的调度任务。</p><h3 id="Fixed-Rate调度任务："><a href="#Fixed-Rate调度任务：" class="headerlink" title="Fixed Rate调度任务："></a>Fixed Rate调度任务：</h3><pre class=" language-Java"><code class="language-Java">  @Scheduled(fixedRate = 2000)  public void scheduleTaskWithFixedRate() {      logger.info("Fixed Rate Task :: Execution Time - {}", dateTimeFormatter.format(LocalDateTime.now()) );  }</code></pre><p>在 <code>@Scheduled</code> 注解中，用 <code>fixedRate</code> 参数可以使得该任务以一个<strong>指定的时间间隔</strong>运行，单位为毫秒。在上例中，任务每两秒钟运行一次，并且即使上一次对任务的调用没有完成，也会按指定的间隔调用<code>fixedRate</code> 任务。<br>输出：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">52</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO <span class="token operator">|</span> Started SpringbootSchedulerApplication in <span class="token number">1.028</span> <span class="token function">seconds</span> <span class="token punctuation">(</span>JVM running <span class="token keyword">for</span> <span class="token number">1.513</span><span class="token punctuation">)</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">52</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">52</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">54</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">54</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">56</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">56</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h3 id="Fixed-Delay调度"><a href="#Fixed-Delay调度" class="headerlink" title="Fixed Delay调度"></a>Fixed Delay调度</h3><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedDelay <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithInitialDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Fixed Delay Task :: Execution Time - {}"</span><span class="token punctuation">,</span> dateTimeFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Ran into an error {}"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">46</span><span class="token operator">:</span><span class="token number">58</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO <span class="token operator">|</span> Started SpringbootSchedulerApplication in <span class="token number">0.983</span> <span class="token function">seconds</span> <span class="token punctuation">(</span>JVM running <span class="token keyword">for</span> <span class="token number">1.416</span><span class="token punctuation">)</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">46</span><span class="token operator">:</span><span class="token number">58</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Delay Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">46</span><span class="token operator">:</span><span class="token number">58</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">47</span><span class="token operator">:</span><span class="token number">03</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Delay Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">47</span><span class="token operator">:</span><span class="token number">03</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">47</span><span class="token operator">:</span><span class="token number">08</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Delay Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">47</span><span class="token operator">:</span><span class="token number">08</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p><code>fixedDelay</code> 参数可以使得您可以在上一次调用完成与下一次调用开始之间以固定的延迟执行任务。这种方式适合于下一次的任务对上一次任务的结果有依赖的情况。从输出也可以看到，日志输出的间隔时间是任务执行时间加上<code>fixedDelay</code> 参数所指定的时间。</p><h3 id="Initial-Delay"><a href="#Initial-Delay" class="headerlink" title="Initial Delay"></a>Initial Delay</h3><p>这种情况是是和上面两种情况搭配使用的，就是不管是使用 <code>fixedRate</code> 参数还是 <code>fixedDelay</code> 都可以使用该参数使得任务的初次执行得到延缓。如下例所示：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> initialDelay <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithInitialDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Fixed Rate Task with Initial Delay :: Execution Time - {}"</span><span class="token punctuation">,</span> dateTimeFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>2019-12-29 17:47:46 [main] INFO | Started SpringbootSchedulerApplication in 1.081 seconds (JVM running for 1.642)2019-12-29 17:47:56 [scheduling-1] INFO | Fixed Rate Task with Initial Delay :: Execution Time - 17:47:562019-12-29 17:47:58 [scheduling-1] INFO | Fixed Rate Task with Initial Delay :: Execution Time - 17:47:582019-12-29 17:48:00 [scheduling-1] INFO | Fixed Rate Task with Initial Delay :: Execution Time - 17:48:00</code></pre><p>在输出中我特意把日志框架打印日志的时间戳给了出来，可以看到 <code>SpringbootSchedulerApplication</code> 启动之后隔了十秒钟（正是<code>initialDelay</code>所指定的延迟时间），调度任务才开始按正常的频率执行。</p><h3 id="Cron表达式任务"><a href="#Cron表达式任务" class="headerlink" title="Cron表达式任务"></a>Cron表达式任务</h3><p>既然是定时任务，又怎么少得了强大的Cron表达式呢。比如在某一个实际应用场景中，我需要在<strong>每天早上九点</strong>把应用的统计信息发到工作群里面，那么我就可以如下配置定时任务：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>cron <span class="token operator">=</span> <span class="token string">"0 0 9 * * ?"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsgTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"sending statistic message with scheduled task"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sendMsgMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="参数化定时任务"><a href="#参数化定时任务" class="headerlink" title="参数化定时任务"></a>参数化定时任务</h3><p>把定时任务的参数硬编码到代码中固然简单，但是当我们需要更改这些参数的时候就需要更改代码然后重新编译部署。这种时候把定时任务参数中写到<strong>配置文件</strong>中，然后使用Spring表达式注入到代码中是更好的选择。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// A fixedDelay task:</span><span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedDelayString <span class="token operator">=</span> <span class="token string">"${fixedDelay.in.milliseconds}"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// A fixedRate task:</span><span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRateString <span class="token operator">=</span> <span class="token string">"${fixedRate.in.milliseconds}"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// A cron expression based task:</span><span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>cron <span class="token operator">=</span> <span class="token string">"${cron.expression}"</span><span class="token punctuation">)</span></code></pre><p>spring直接支持的简单定时任务就已经讲完了。<br>其中被 <code>@Scheduled</code> 标注的调度方法有两个需要注意的点是：</p><ol><li>返回类型应该是 <code>void</code> </li><li>方法不能有入参</li></ol><h2 id="多线程定时任务"><a href="#多线程定时任务" class="headerlink" title="多线程定时任务"></a>多线程定时任务</h2><p>从上面例子中的输出日志可以看到，调度任务的执行是在一个默认线程名为 <code>scheduling-1</code> 的独立线程中执行的。事实上，通过这种方式配置的定时任务默认是在<strong>单线程</strong>中运行的。这意味着什么呢？意味着如果当前任务任务没有运行完，可能下一个任务不会开始，即被阻塞。同一个定时任务的<strong>上一次运行</strong>或者多个定时任务之前都可能发生阻塞。在上面介绍 <code>fixedRate</code> 任务的时候，我们说到：</p><blockquote><p>即使上一次对任务的调用没有完成，也会按指定的间隔调用 fixedRate 任务<br>但是实验发现，这可以说只是它的“设计目标”，实际上指定间隔到了之后，如果上一次的任务还没有执行完会发生什么呢？</p></blockquote><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Fixed Rate Task :: Execution Time - {}"</span><span class="token punctuation">,</span> dateTimeFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">19</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">19</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">22</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">22</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">29</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span>scheduling<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">43</span><span class="token operator">:</span><span class="token number">25</span></code></pre><p>可以看到，<code>fixedRate</code>虽然指定的是两秒，但是执行结果却是三秒一次，也就是每次任务的执行时间（用sleep表示）。如果是多个不同的定时任务，如果其中一个定时任务指定完之后已经过了另外一个任务应该执行的时间点了，那么这个“定时”就已经不再是准确意义上的定时了，我们把这称为<strong>问题B</strong>。这两种情况总结成如下<strong>问题定义</strong></p><ul><li><strong>问题A</strong> 同一个定时任务多次运行，按时间排队运行；</li><li><strong>问题B</strong> 多个定时任务时间冲突，排队运行。</li></ul><p>这两个问题发生的根本原因就是 <code>@EnableScheduling</code> 开启的调度默认是使用单线程（更严谨一点是线程数为1的线程池）执行 task 的，任务排队调用。<br>那么就可以自然而然地想到，解决方式就是使用线程池。</p><h2 id="定时任务指定线程池"><a href="#定时任务指定线程池" class="headerlink" title="定时任务指定线程池"></a>定时任务指定线程池</h2><p>在jdk中，我们使用 <code>Timer</code> 来执行定时任务，spring 为这种调度提供了自己的抽象–<code>TaskScheduler</code>，提供如下抽象方法及多个重载：</p><pre><code>schedule()scheduleAtFixedRate()scheduleWithFixedDelay()</code></pre><p>这和我们之前用注解的方式实现的调度任务对比一下就能发现他们之间的联系：注解的底层就是用这个抽象来实现功能的。<br>我们可以通过为 spring 提供配置过的 <code>TaskScheduler</code> 的 bean 来覆盖默认的单线程配置。而  <code>TaskScheduler</code> 是一个接口，其实现类 <code>ThreadPoolTaskScheduler</code> 才是我们通常使用的目标，实现 <code>SchedulingConfigurer</code> 接口就能对其进行配置 ：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SchedulerConfig</span> <span class="token keyword">implements</span> <span class="token class-name">SchedulingConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configureTasks</span><span class="token punctuation">(</span>ScheduledTaskRegistrar scheduledTaskRegistrar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolTaskScheduler scheduler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduler<span class="token punctuation">.</span><span class="token function">setPoolSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduler<span class="token punctuation">.</span><span class="token function">setThreadNamePrefix</span><span class="token punctuation">(</span><span class="token string">"schedule-task-pool-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduler<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduledTaskRegistrar<span class="token punctuation">.</span><span class="token function">setTaskScheduler</span><span class="token punctuation">(</span>scheduler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到，这里可以通过 <code>setPoolSize()</code> 方法设置线程池的大小，并且可以通过 <code>setThreadNamePrefix()</code> 方法设置线程池名字的前缀，方便跟踪调试。需要注意的是配置好参数只会一定要调用 <code>initialize()</code> 方法，否则会报错：</p><pre><code>java.lang.IllegalStateException: ThreadPoolTaskScheduler not initialized</code></pre><p>如果需要对线程池进行更精细的控制，<code>ThreadPoolTaskScheduler</code> 本身的类方法还不够，但是可以通过 spring 封装的线程池类 <code>ThreadPoolTaskExecutor</code> 进行间接设置：</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configureTasks</span><span class="token punctuation">(</span>ScheduledTaskRegistrar scheduledTaskRegistrar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolTaskExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setThreadNamePrefix</span><span class="token punctuation">(</span><span class="token string">"scheduled-pool-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadPoolTaskScheduler scheduler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduler<span class="token punctuation">.</span><span class="token function">setThreadFactory</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduler<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        scheduledTaskRegistrar<span class="token punctuation">.</span><span class="token function">setTaskScheduler</span><span class="token punctuation">(</span>scheduler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>或者也可以直接通过提供 <code>ThreadPoolTaskExecutor</code> 的 bean 配置线程池：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ThreadPoolTaskExecutor <span class="token function">getExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolTaskExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setQueueCapacity</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> executor<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>配置好线程池之后，我们来运行一下同时包含上述 <code>fixedRate</code> 和 <code>fixedDelay</code> 两个定时任务的应用，输出如下：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">35</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">35</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">35</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Delay Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">35</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">37</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">37</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">39</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">39</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">40</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Delay Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">40</span></code></pre><p>这时，不同的定时任务可以在不同的线程中得到并发。上述<strong>问题B</strong>得到了解决。<br>再来看<strong>问题A</strong>，配置了线程池之后再重新运行以下代码：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Fixed Rate Task :: Execution Time - {}"</span><span class="token punctuation">,</span> dateTimeFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">25</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">28</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">28</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">31</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">31</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">34</span> <span class="token punctuation">[</span>schedule<span class="token operator">-</span>task<span class="token operator">-</span>pool<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">34</span></code></pre><p>很不幸的是，从输出可以看出虽然每次执行都可能使用不同的线程，但是依然会等到上一次任务执行完成之后才会开始下一次执行，因为间隔时间是3秒而不是2秒。这说明即使配置了线程池也<strong>无法让同一个定时任务的多次运行之间并发</strong>。<br>要<strong>实现同一个任务的并发</strong>这个目的，需要使用<strong>异步执行</strong>。首先像上面的  <code>@EnableScheduling</code> 一样，使用 <code>@EnableAsync</code> 开启对异步的支持。然后在调度任务上使用 <code>@Async</code> 注解表示该方法是个异步任务：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Async</span><span class="token punctuation">(</span><span class="token string">"taskExecutor"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 可以根据bean name指定线程池</span>    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleTaskWithFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Fixed Rate Task :: Execution Time - {}"</span><span class="token punctuation">,</span> dateTimeFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">04</span> <span class="token punctuation">[</span>taskExecutor<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">04</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">06</span> <span class="token punctuation">[</span>taskExecutor<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">06</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">08</span> <span class="token punctuation">[</span>taskExecutor<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> INFO <span class="token operator">|</span> Fixed Rate Task <span class="token operator">:</span><span class="token operator">:</span> Execution Time <span class="token operator">-</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">08</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>这次可以看到该任务的每次运行使用不同的线程，并且可以做到并发。这样就解决了上述的<strong>问题B</strong>。<br>进一步地，如果并发任务可以通过 <code>@Async</code> 指定某个具体的线程池的话，那么可以提供多线程池的bean，然后通过 <code>@Async</code> 把不同的任务分配到不同的线程池中去执行。<br>对于 <code>@Async</code> 标注的方法，有两点需要注意的：</p><ol><li>它只能用于 <code>public</code> 方法；</li><li>如果它被类内部的方法调用的话，异步功能无法生效。<br>这两点其实在使用代理实现功能的注解上都需要注意，比如说用于缓存的 <code>@Cacheable</code> 注解。因为方法只有是 <code>public</code> 的才能被正确代理，并且如果调用来自类内的话，就会越过代理而调用真实方法，无法实现注解所表示的功能。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了springboot自带的定时任务的基本用法及他们之间的区别，对于简单的业务场景，这种 out-of-box 的工具对用户是非常友好的。同时也指出了其默认使用单线程处理同一个任务的多次运行以及多个任务的运行，这样对于较为耗时的操作可能会导致阻塞。然后针对这两种情况给出了使用多线程运行定时任务的方案。</p><p>文中代码可在<a href="https://github.com/mooba/springBoot-study/tree/master/springboot-scheduler" target="_blank" rel="noopener">GitHub</a>找到。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
            <tag> scheduler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[译]理解compare-and-swap（CAS）</title>
      <link href="/2019/11/22/yi-li-jie-compare-and-swap-cas/"/>
      <url>/2019/11/22/yi-li-jie-compare-and-swap-cas/</url>
      
        <content type="html"><![CDATA[<p><em>compare-and-swap (CAS)</em> 指令是一个不可中断的操作（原子操作），它读取一个<strong>内存地址</strong>，把<strong>读取到的值</strong>和一个<strong>期望值</strong>进行比较，当读取的值和期望值相等的时候，就把该内存地址的值更新为一个新的值，否则就什么也不做。这个过程根据不同的微处理器指令可能有些许不同（比如，如果 CAS 成功的话返回 true，否则返回 false，而不是下面实例中的做法——返回读取的值）。</p><blockquote><p><strong>微处理器 CAS 指令</strong>：</p><p>现代的微处理器本省提供了某种 CAS 指令。比如说，Intel 微处理器提供了 <code>cmpxchg</code> 指令族，而 PowerPC 微处理器提供了 <code>load-link</code>（e.g., <code>lwarx</code>）和 <code>store-conditional</code>（e.g., <code>stwcx</code>）指令用于相同的目的。</p></blockquote><p>CAS 使得 <strong>read-modify-write</strong> <strong>操作序列</strong>作为原子操作成为可能。通常我们会按照如下过程使用 CAS：</p><ol><li>从地址X读取值v</li><li>执行一个多步计算得到一个新的值v2</li><li>使用CAS尝试把地址X上的值从v改成v2，当执行这些步骤时X的值未更改，则CAS执行成功。</li></ol><p>为了搞清楚CAS是怎样比<code>synchronization</code>提供更好的性能（和可扩展性），举个例子：有一个计数器，允许你读它的当前值并且对值进行累加。下面的类基于<code>synchronization</code>实现了一个计数器：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Counter.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token operator">++</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>monitor lock 的高竞争会导致大量的上下文切换，从而使所有的线程延迟，并导致应用程序无法很好地扩展。</p><p>取而代之的是使用 CAS 的代码实现<code>compare-and-swap</code>操作。下面的类模拟了 CAS ，但是使用的是<code>synchronized</code>而不是实际的硬件指令，用于简化代码:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// EmulatedCAS.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmulatedCAS</span><span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">compareAndSwap</span><span class="token punctuation">(</span><span class="token keyword">int</span> expectedValue<span class="token punctuation">,</span> <span class="token keyword">int</span> newValue<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">int</span> readValue <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>readValue <span class="token operator">==</span> expectedValue<span class="token punctuation">)</span>         value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>      <span class="token keyword">return</span> readValue<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中，<code>value</code>代表了一个内存地址，可以通过<code>getValue()</code>方法获取值。相应地，<code>compareAndSwap()</code>实现了 CAS 算法。</p><p>下面一个类使用<code>EmulatedCAS</code>实现了一个<code>non-synchronized</code>的计数器（这里假设<code>EmulatedCAS</code>不需要<code>synchronized</code>）:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Counter.java (version 2)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> EmulatedCAS value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EmulatedCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">int</span> readValue <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">compareAndSwap</span><span class="token punctuation">(</span>readValue<span class="token punctuation">,</span> readValue<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> readValue<span class="token punctuation">)</span>         readValue <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> readValue<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Counter</code>封装了<code>EmulatedCAS</code>实例，并且通过这个实例提供的功能声明了用于获取值和增加计数器值的方法。即，<code>getValue()</code>获取该实例的“当前计数器值”，<code>increment()</code>安全地增加计数器的值。</p><p><code>increment()</code>重复调用<code>compareAndSwap()</code> 直到 <code>readValue</code>的值不再改变，然后就可以改变这个值了。当没有锁牵涉其中的时候，就可以避免竞争以及随之而来的大量上下文切换了。这样性能和代码的可扩展性就能得到提高。</p><blockquote><p>你可能之前了解到<code>ReentrantLock</code> 在高线程争用情况下能够比 <code>synchronized</code>提供更好的性能表现。为了提高性能，<code>ReentrantLock</code>的同步是通过抽象类<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>的一个子类来管理的。进一步地，该类利用了未开源的<code>sun.misc.Unsafe</code>类中的<code>compareAndSwapInt()</code>这个 CAS 实现。</p></blockquote><p><a href="https://www.javaworld.com/article/2078848/java-concurrency-java-101-the-next-generation-java-concurrency-without-the-pain-part-2.html?page=3" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> CAS </tag>
            
            <tag> concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j和log4j2在springboot中的性能对比</title>
      <link href="/2019/11/17/log4j-he-log4j2-zai-springboot-zhong-de-xing-neng-dui-bi/"/>
      <url>/2019/11/17/log4j-he-log4j2-zai-springboot-zhong-de-xing-neng-dui-bi/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 java 项目中最常用的三大日志框架是<code>logback</code>，<code>log4j</code>，<code>log4j2</code>。其中<code>logback</code>是 springboot 的默认框架。由于历史原因，我手上有个springboot项目的日志框架是用的<code>log4j</code>。在对某个接口进行压测和性能优化的时候发现，打印同步日志会导致接口的性能缩水，所以当时直接把性能要求高的接口的日志关闭掉了。随着系统的逐渐复杂，重要性越来越高，定位问题的难度越来越大，我逐渐感觉到日志的的重要性。所以优化日志势在必行。<br>我是从两个方面来考虑<strong>优化日志</strong>这个问题的。</p><ol><li>更换性能更高的日志框架；</li><li>使用异步日志或者延时刷盘的日志配置。</li></ol><p>对第一个问题，很容易就可以Google到，目前性能表现最好的日志框架是<code>log4j2</code>，所以直接把日志框架替换成<code>log4j2</code>就可以了。</p><p>对于第二个问题，因为当前日志是同步的，需要把“打印日志”这个操作完成之后才会运行接下来的业务代码，而“打印日志”通常是要输出到控制台或者文件中的，IO开销很大，如果把这个过程变成异步的应该能从一定程度上提高性能表现。</p><p>不知道在哪听到的两句话，想在这里分享一下：</p><ol><li>没有日志的系统就像在裸奔</li><li>没有uid的日志是没有灵魂的</li></ol><p>PS：这里没有uid的本来是指是调用方的id，更一般的说法就是不能定位问题的日志是没有存在价值的。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>springboot 2.1.5</li><li>java 8</li><li>MacBook Pro 2017</li></ul><h2 id="log4j日志"><a href="#log4j日志" class="headerlink" title="log4j日志"></a>log4j日志</h2><h3 id="log4j-在-springboot-中的配置"><a href="#log4j-在-springboot-中的配置" class="headerlink" title="log4j 在 springboot 中的配置"></a>log4j 在 springboot 中的配置</h3><p>在 springboot 中使用 log4j 需要引入其依赖并把 springboot 自带的日志框架 logback 排除掉:</p><pre class=" language-xml"><code class="language-xml">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.8.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>然后编写配置文件<code>log4j.properties</code>:</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">log4j.rootLogger</span><span class="token punctuation">=</span><span class="token attr-value">INFO,stdout,file</span><span class="token attr-name">log4j.appender.stdout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.ConsoleAppender</span><span class="token attr-name">log4j.appender.stdout.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.stdout.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%d{yyyy-MM-dd HH:mm:ss} [%p] %c:[%L] %m%n</span><span class="token attr-name">log4j.appender.file</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.DailyRollingFileAppender</span><span class="token attr-name">log4j.appender.file.File</span><span class="token punctuation">=</span><span class="token attr-value">logs/seller_penalty_api_server.log</span><span class="token attr-name">log4j.appender.file.Append</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">log4j.appender.file.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.file.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%d{yyyy-MM-dd HH:mm:ss} [%p] %c:[%L] %m%n</span></code></pre><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>知己知彼，百战不殆。</p><p>要对比性能，首先就要知道原来的<code>log4j</code>框架的性能表现如何。</p><p>这里我使用了一种简单的方式来进行对比。在 springboot 中实现两个简单的接口，一个打印一行日志，一个不打印日志，然后用<code>wrk</code>工具对接口进行压测，看两个接口能够达到的QPS分别是多少。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 不打印日志</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/ping"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">"pang"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 打印日志</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"pingLog"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">pingWithLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"calling /pingLog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token string">"pangLog"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>压测配置如下，分别对两个接口进行多次压测，取三次作为采样结果。</p><pre class=" language-shell"><code class="language-shell">wrk -t10 -c250 -d30s http://localhost:8080/ping</code></pre><table><thead><tr><th>采样次数</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>不打印日志</td><td>21937.40</td><td>23570.31</td><td>22950.31</td></tr><tr><td>打印日志</td><td>7825.40</td><td>7848.33</td><td>7788.54</td></tr></tbody></table><p>可以看到两种情况基本上有将近三倍的差距。我是用nohup后台运行的，如果直接使用<code>java -jar</code>运行，日志输出到文件的同时还会输出到控制台，这种情况QPS将进一步降低，大概在5k+左右。这也正是我们最开始为了接口性能选择关闭日志的原因</p><h2 id="log4j2"><a href="#log4j2" class="headerlink" title="log4j2"></a>log4j2</h2><p>引入log4j2（同log4j一样，要排除 springboot 自带的日志框架）：</p><pre class=" language-xml"><code class="language-xml">       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-log4j2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 增加识别yaml格式依赖，加上这个才能辨认到log4j2.yml文件 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.dataformat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-dataformat-yaml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>然后在<code>src/main/resources/</code>路径中编写<code>log4j2</code>的配置文件。默认配置文件名是<code>log4j2</code>，支持xml、properties、json、yaml多种文件格式，这里我选了yml，所以需要额外引入<code>jackson-dataformat-yaml</code>的包。</p><pre class=" language-yml"><code class="language-yml">Configuration:  status: debug  appenders: # 包含控制台和文件两个appender    Console:      name: LogToConsole      PatternLayout:        Pattern: "%d{yyyy-MM-dd HH:mm:ss} [%p] %c:[%L] %m%n"    RollingFile:      - name: LogToRollingFile        fileName: logs/seller_penalty_api_server.log        filePattern: "logs/seller_penalty_api_server.log.%d{yyyy-MM-dd}.gz" # 带有后缀名会自动压缩        PatternLayout:          pattern: "%d{yyyy-MM-dd HH:mm:ss} [%p] %c:[%L] %m%n"        Policies:          TimeBasedTriggeringPolicy: # 基于时间的trigger，每天一个文件            interval: 1  Loggers:    logger:      - name: io.shopee.bigdata.penalty.server        level: debug        additivity: false        AppenderRef:          - ref: LogToConsole          - ref: LogToRollingFile    Root:      level: error      AppenderRef:        ref: LogToConsole</code></pre><p>使用<code>log4j2</code>之后，使用<code>wrk</code>和同样的参数压测（关掉控制台输入），三次测试的QPS分别是：</p><table><thead><tr><th>采样次</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>QPS</td><td>13992.50</td><td>15562.27</td><td>15161.16</td></tr></tbody></table><p>可以看到在这个简单的场景下，性能几乎是log4j的2到3倍之多！所以很明显，首先替换日至框架是一个明智的选择。</p><h3 id="log4j2-异步日志"><a href="#log4j2-异步日志" class="headerlink" title="log4j2 异步日志"></a>log4j2 异步日志</h3><p>到目前为止，上述的测试都是针对同步日志进行的测试。在确定了<code>log4j2</code>作为日志框架之后，我想看一下，使用异步日志能不能进一步提高性能表现。</p><h3 id="AsyncAppender-和-Asynchronous-Loggers"><a href="#AsyncAppender-和-Asynchronous-Loggers" class="headerlink" title="AsyncAppender 和 Asynchronous Loggers"></a>AsyncAppender 和 Asynchronous Loggers</h3><p>在<code>log4j2</code>中异步日志有两种实现<code>AsyncAppender</code> 和 <code>Asynchronous Loggers</code> </p><p>前者是 <code>log4j2</code> 最开始的异步日志实现，它把其他 Appender 作为输入，然后把产生 <code>logEvent</code>输出到默认的容器<code>ArrayBlockingQueue</code>中，然后使用另外一个线程中来输出日志以实现异步。但是官方文档也指出：</p><blockquote><p>在这种多线程应用的实践中需要主要：阻塞队列很容易发生锁争用，测试表明当大量线程并发写日志的时候，性能甚至会变得更糟糕。所以应该考虑使用<strong>无锁的Asyn Loggers</strong>进行优化。</p></blockquote><p>上述的<code>Asyn Loggers</code>是<code>log42</code> 团队后来才加入的异步实现，连官方文档都推荐它了，那还有什么好犹豫的呢。它需要引入一个额外的依赖：</p><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.lmax<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>disruptor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><code>Disruptor</code> 通过<code>CAS</code>而不是锁实现多生产者、多消费者对<code>RingBuffer</code>的并发访问，实现高吞吐和高性能。</p><p>它们两者的具体区别可以参考<a href="https://www.cnblogs.com/yeyang/p/7944906.html" target="_blank" rel="noopener">参考资料2</a></p><h3 id="全异步和混合异步"><a href="#全异步和混合异步" class="headerlink" title="全异步和混合异步"></a>全异步和混合异步</h3><p>Log4j2的异步日志的使用又可以分为<strong>全异步</strong>和<strong>混合异步</strong>，所谓全异步就是所有的日志都以异步方式输出；混合异步就是只有指定的代码文件用异步方式输出，其他日志使用同步方式输出；前者能够获得更高的性能，也是官方推荐的方式，后者具有更好的灵活性，可以进行针对性配置。</p><p>本文中我们直接使用全异步日志。</p><p>在springboot中开启全异步的方式很简单，只需要在配置文件中加如下配置（yml）：</p><pre class=" language-yml"><code class="language-yml">log4j2:  contextSelector: org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</code></pre><p>或者在用<code>java -jar</code> 启动的时候加入系统参数：</p><pre class=" language-shell"><code class="language-shell">-DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</code></pre><p>应用启动之后按照上述的方法测试接口性能：</p><table><thead><tr><th>采样次</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>QPS</td><td>16238.76</td><td>16006.78</td><td>16322.12</td></tr></tbody></table><p>可以看到把日志从同步改成异步之后，性能有一定提升，但是并没有想象中那么大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>同步日志和业务逻辑在同一个线程中，当日志输出完毕才能执行接下来的代码，涉及到IO，非常影响性能；</li><li><code>log4j2</code> 在本文的简单场景中性能要远远高于 <code>log4j</code>，这次替换是值得的；</li><li><code>log4j2</code> 异步日志应该使用 <code>Asynchronous Loggers</code> 而不是 <code>AsyncAppender</code> </li><li>本次测试是基于一个很简单的场景，在官方文档中，异步日志的性能要远远超过同步日志的，但是在本次测试中并没有体现出来；日志在 springboot 中的性能可能受多个方面的影响，比如每个调用链中日志的条数、springboot本身的配置，日志的level、硬件环境等。</li><li>项目代码见<a href="https://github.com/mooba/springBoot-study/tree/master/springboot2-logging" target="_blank" rel="noopener">Github</a></li></ol><h2 id="彩蛋1-性能测试需要注意的点"><a href="#彩蛋1-性能测试需要注意的点" class="headerlink" title="彩蛋1-性能测试需要注意的点"></a>彩蛋1-性能测试需要注意的点</h2><p>关于性能测试，在 log4j2 的官方文档中提到的几点我觉得是比较通用的:</p><ul><li>获取性能的采样结果之前需要 <em>warm up the JVM</em>；</li><li>重复热身多次，然后等待IO线程赶上并释放缓冲区;</li><li>测试的时候重复多次取平均数。</li></ul><p>总结一下就是系统刚启动的一段时间的测试数据不能作为参考，需要压测一段时间，取稳定之后的结果。就像运动前的热身一样，不光JVM，各种线程池或连接池都需要一段时间的请求才能启动起来进入正常工作状态。</p><h2 id="彩蛋2-springboot-中多环境日志配置"><a href="#彩蛋2-springboot-中多环境日志配置" class="headerlink" title="彩蛋2-springboot 中多环境日志配置"></a>彩蛋2-springboot 中多环境日志配置</h2><p>在springboot中我们通常针对dev，test，live等多种环境会有多套配置文件，比如<code>application-dev.yml</code>,<code>application-test.yml</code>, <code>application-live.yml</code>。然后可以在启动的时候可以通过在全局配置文件<code>application.yml</code>指定某个配置文件来启用配置：</p><pre class=" language-yml"><code class="language-yml">sping:  profiles:    active: live</code></pre><p>日志同样有这样的需求，不同环境使用不同的日志配置，比如dev或test环境需要开启的log level为<code>DEBUG</code>，而在live环境中却不需要。这种时候我们只需要写多套日志配置，比如<code>log4j2-dev.yml</code>，<code>log4j2-test.yml</code>，<code>log4j2-live.yml</code>，然后在其对应的配置文件中启用日志配置就可以了：</p><pre class=" language-yml"><code class="language-yml">logging:  config: classpath:log4j2-dev.yml</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.mkyong.com/spring-boot/spring-boot-log4j-2-example/" target="_blank" rel="noopener">Spring Boot Log4j 2 example</a></li><li><a href="https://www.cnblogs.com/yeyang/p/7944906.html" target="_blank" rel="noopener">Log4j2中的同步日志与异步日志</a></li><li><a href="https://stackoverflow.com/questions/24177601/difference-between-asynclogger-and-asyncappender-in-log4j2" target="_blank" rel="noopener">Difference between Asynclogger and AsyncAppender in Log4j2</a></li><li><a href="https://www.callicoder.com/spring-boot-log4j-2-example/" target="_blank" rel="noopener">https://www.callicoder.com/spring-boot-log4j-2-example/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
            <tag> log4j2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 自动配置浅析</title>
      <link href="/2019/10/28/springboot-zi-dong-pei-zhi-qian-xi/"/>
      <url>/2019/10/28/springboot-zi-dong-pei-zhi-qian-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>我们知道，SpringBoot之所以强大，就是因为他提供了各种默认的配置，可以让我们在集成各个组件的时候从各种各样的配置文件中解放出来。</p><p>拿一个最普通的 web 项目举例。我们需要使用 servlet 容器，SpringBoot 就提供了嵌入式的 Tomcat 作为默认容器，不需要一行配置就能直接以最普通的 Java 程序的方式启动：<code>java -jar</code>；接收请求需要一个网络端口，默认配置好<code>8080</code>；处理请求需要 servlet 的多线程特性，默认配置好了最大线程数为<code>200</code>；处理好的请求以<code>Restful</code> 风格返回给调用方，SpringBoot 默认配置好了<code>jackson</code>进行 json 序列化，业务代码需要做的只是返回一个 POJO 对象；连接池直接就默认配置了性能最好的的 <code>Hikari</code>，以及连接池的默认尺寸为10……在一个简单的web应用中，这些配置我们甚至都可能不了解或者没有意识到它们的存在，就可以让程序正常运行。</p><p>这就是自动配置的魔力——润物细无声。</p><p>那么自动配置是怎么实现的呢？本文就从<code>POM</code>文件和 <code>@SpringBootApplication</code> 注解来简单分析一下自动配置原理。</p><p>真的只是<strong>简单地</strong>，分析一下。</p><h2 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>SpringBoot 2.0.6</li></ul><h3 id="父项目"><a href="#父项目" class="headerlink" title="父项目"></a>父项目</h3><p>在每一个 SpringBoot 项目一开始的 POM 文件中，就有一个<strong>父依赖</strong>：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span></code></pre><p>点进<code>artifactId</code>之后来到 <code>spring-boot-starter-parent-2.0.6.RELEASE.pom</code> 文件，这个文件还有一个父依赖：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">></span></span>../../spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relativePath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span></code></pre><p>再继续点进去来到 <code>spring-boot-dependencies-2.0.6.RELEASE.pom</code> 文件中。在该文件的 <code>&lt;properties&gt;</code> 标签中可以看到各种各样的组件的版本信息， <code>&lt;dependencyManagement&gt;</code> 标签中声明了各个组件的maven坐标信息。其中，我数了一下，在 <code>SpringBoot 2.0.6</code> 中一个有177个带有版本信息的组件名，包括了大家熟悉的 elasticsearch、activemq、redis、kafka等等。</p><p>这里（<code>spring-boot-dependencies-2.0.6.RELEASE.pom</code>文件）称为 SpringBoot 的“<strong>版本仲裁中心</strong>”，它是用来管理 SpringBoot 应用里面的所有依赖版本的地方。 它包含了大部分开发中会用到的一些组件的版本，所以我们导入依赖默认是不需要写版本号的，SpringBoot 会自动帮我们配置需要的版本。这样在引入某个组件的时候不用考虑这个组件和系统中已有的组件兼不兼容之类的问题，避免了烦人的版本冲突问题。（当然，没有在 dependencies里面管理的依赖自然需要声明版本号)  </p><h3 id="启动器（Starters）"><a href="#启动器（Starters）" class="headerlink" title="启动器（Starters）"></a>启动器（Starters）</h3><p>父项目做版本仲裁，那么真正的 jar 包是从哪里导入进来的呢？这就要说到我们的starters了。点开web-starter可以看到它帮我们导入了web模块正常运行所依赖的组件，就不用我们一个一个手动导入了。</p><p>所以，所谓的Starters就是一系列依赖描述的组合，我们可以通过导入这些starters就会有相应的依赖了并可以基于他们进行相应的开发</p><p>Springboot把开发中中会遇到的场景都抽象成一个个的starter，比如（），只需要在项目里面引入这些starter 相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>一个典型的 springboot 项目的入口类如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>DemoApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>只要运行<code>main</code>方法就能启动该应用。<code>main</code> 中运行 run 方法时需要传入一个类，这个类正是使用<code>@SpringBootApplication</code>注解标注的类，如果没有这个注解程序是跑不起来的。</p><p>这个注解标注在某个类上就说明这个类是 springboot 的主配置类，springboot 就应该运行这个类的 main 方法来启动springboot应用</p><p>点开这个注解的源码，可以看到这是一个组合注解，最主要的是这两个注解：</p><ul><li><p><code>@SpringBootConfiguration</code></p></li><li><p><code>@EnableAutoConfiguration</code> </p></li></ul><p><code>@SpringBootConfiguration</code>标注在某个类上，表示这是一个 SpringBoot 的配置类，它的底层是<code>@Configuration</code>，属于spring的底层注解，标注了这个注解的类表名这个类是一个配置类，取代以前开发中的xml文件配置，同时也表明这个类是 spring 容器中的组件，受容器管理。</p><p>接下来是<code>@EnableAutoConfiguration</code>注解，它的用处是<strong>开启自动配置</strong>，使用 spring 开发需要手动配置的东西，现在由 springboot 帮我们配置了，具体的实现就是通过这个注解来实现的。该组合注解有两个。</p><h3 id="1-AutoConfigurationPackage"><a href="#1-AutoConfigurationPackage" class="headerlink" title="1. @AutoConfigurationPackage"></a>1. @AutoConfigurationPackage</h3><p>它的 注解中的核心代码是 <code>@Import({Registrar.class})</code>。</p><p> <code>@Import</code> 的作用就是为容器中导入一个它指定的组件。</p><p>在 <code>Registrar</code> 这个类中有一个方法叫<code>registerBeanDefinitions</code>，用于注册一些 bean 定义信息：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">,</span> BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>     AutoConfigurationPackages<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AutoConfigurationPackages<span class="token punctuation">.</span>PackageImport</span><span class="token punctuation">(</span>metadata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>打个断点在这一行代码上，运行</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AutoConfigurationPackages<span class="token punctuation">.</span>PackageImport</span><span class="token punctuation">(</span>metadata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>得到的结果是<strong>主配置类所在的包名</strong>，目的就是将主配置类所在包及<strong>下面所有子包里面的所有组件扫描到Spring容器中</strong>。同时也说明了，如果在主配置所在包的上层包添加组件的话是不会被扫描到的、不起作用的。</p><h3 id="2-Import-AutoConfigurationImportSelector-class"><a href="#2-Import-AutoConfigurationImportSelector-class" class="headerlink" title="2. @Import({AutoConfigurationImportSelector.class})"></a>2. @Import({AutoConfigurationImportSelector.class})</h3><p>该注解导入了一个自动配置的<strong>选择器</strong>，真正地给容器中导入 springboot 自动帮我们配置好的配置类。在 <code>AutoConfigurationImportSelector</code> 这个选择器中的 <code>getAutoConfigurationEntry</code> 方法中，以<strong>全限定类名</strong>的方式把所有需要的配置类导入 springboot 容器中。这些全限定类型所在文件路径为：</p><pre><code>org/springframework/boot/spring-boot-autoconfigure/2.1.8.RELEASE/spring-boot-autoconfigure-2.1.8.RELEASE.jar!/META-INF/spring.factories</code></pre><p>上述两个注解一个负责扫描我们<strong>将要加容器中的类</strong>，一个加入 <strong>springboot 为我们自动配置好的类</strong>，springboot 通过这两种方式省略了我们大量的配置工作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从用于maven项目管理的<code>pom.xml</code>文件和标注在启动类上的<code>@SpringBootApplication</code>注解，简单分析了springboot 自动配置的实现。前者通过<strong>版本仲裁中心</strong>为我们维护项目组件的版本，防止依赖冲突；后者通过在加载程序的时候导入数以百计的自动配置类实现自动配置。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 简介</title>
      <link href="/2019/10/28/springboot-jian-jie/"/>
      <url>/2019/10/28/springboot-jian-jie/</url>
      
        <content type="html"><![CDATA[<p>认识一个东西我们先来试着回答三个经典的问题问题，是什么？为什么？怎么样？</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>在介绍 SpringBoot 之前我们首先来简单介绍一下 Spring。Spring 是诞生于2002年的 Java 开发框架，可以说已经成为 Java 开发的事实标准。所谓事实标准就是虽然 Java 官方没有说它就是开发标准，但是在当前 Java 开发的众多项目中，当我们谈到产品级的 Java 项目的时候，大多都是基于 Spring 或者应用了 Spring 特性的。</p><p>Spring 基于 IOC 和 AOP 两个特性对 Java 开发本身进行了大大的简化。但是一个大型的项目需要集成很多其他组件，比如一个 WEB 项目，至少要集成 MVC 框架、Tomcat 这种 WEB 容器、日志框架、ORM框架，连接数据库要选择连接池吧……使用 Spring 的话每集成一个组件都要去先写它的配置文件，比较繁琐且容易出错。</p><p>然后就有了SpringBoot。</p><p>Spring Boot 是由 Pivotal 团队提供的全新框架，2014 年 4 月发布 Spring Boot 1.0 2018 年 3 月 Spring Boot 2.0发布。它是对spring的进一步封装，其设计目的是用来简化 Spring 应用的初始搭建以及开发过程。怎么简化的呢？就是通过封装、抽象、提供默认配置等方式让我们更容易使用。</p><p>SpringBoot 基于 Spring 开发。SpringBoot 本身并不提供 Spring 框架的核心特性以及扩展功能，也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p>关于 SpringBoot 有一句很出名的话就是<strong>约定大于配置</strong>。采用 Spring Boot 可以大大的简化开发模式，它集成了大量常用的第三方库配置，所有你想集成的常用框架，它都有对应的组件支持，例如 Redis、MongoDB、Jpa、kafka，Hakira 等等。SpringBoot 应用中这些第三方库几乎可以零配置地开箱即用，大部分的 SpringBoot 应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么会产生 SpringBoot 呢？</p><p>刚才说 SpringBoot 简化了基于 Spring 开发，这只是最直观的一方面，事实上 SpringBoot 的诞生有它所处的大时代背景这个原因在里面的，那就是微服务，这也是谈 SpringBoot 必谈微服务的原因。</p><img src="https://i.loli.net/2019/10/28/Qq9ywef6MlPEkCT.jpg" alt="martin_fowler.jpg" style="zoom:50%;" /><p>2014年一个叫 Martin Fowler （同时也是经典著作《重构：改善既有代码的设计》一书的作者）发表了一篇关于<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">微服务的博客</a>，比较形象生动地介绍了什么是微服务，然后微服务才慢慢被人所熟知。他说微服务其实是一种架构风格，我们在开发一个应用的时候这个应用应该是由一组小型服务组成，每个小型服务都运行在自己的进程内；小服务之间通过HTTP的方式进行互联互通。和微服务相对应的就是我们之前的，单体应用，就是大名鼎鼎的 all in one 的风格。这种风格把所有的东西都写在一个应用里面，比如我们熟悉的OA，CRM，ERP系统，所有的页面，所有的代码都放在一起，打成打成一个war包，然后把war包放在Tomcat容器中运行。</p><p><img src="https://i.loli.net/2019/10/28/DXS84IniF7YrKBW.png" alt="microservice.png"></p><p>这种传统web开发的架构模式当然也有它的优势，比如它测试部署比较简单，因为不涉及到多个服务的互联互调，只需要把一个包上传到服务器就行了，可以说是一人吃饱全家不饿。同样也不会给运维带来麻烦，方便水平扩展，只需要又把相同的应用复制多份放在不同的服务器中就达到了扩展的目的。</p><p>单体应用的的缺点也显而易见，容易牵一发而动全身，比如要更改一个小小的功能，就可能需要重新部署整个应用。当然，更大的挑战就是日益增长的用户需求。</p><h2 id="怎么样"><a href="#怎么样" class="headerlink" title="怎么样"></a>怎么样</h2><p>介绍了一大堆，那 SpringBoot 的开箱即用是怎么体现的呢。</p><p>SpringBoot 官方推荐的构建应用的方式是使用 <a href="https://start.spring.io/" target="_blank" rel="noopener">Spring Initializr</a>，直接在网页上选择好构建工具、语言、SpringBoot 版本，填好自己的项目名和初始依赖，然后点<strong>Generate</strong> 按钮，就能下载一个构建好的工程的zip包，只需要把这个包解压之后导入IDE就可以了。</p><p>这已经是一个包含依赖的、完整的、可独立运行的springboot应用了！你所需要做的就是往里面填充自己的业务代码！</p><p>当然，如果能直接使用IDE来进行上述操作可以让这个过程变得更顺滑。如果你使用的是 IDEA 商业版的话，新建工程的时候直接有 Spring 的选项；如果是IDEA社区版的话，可以安装 <code>Spring Assistant</code> 这个插件可以实现同样的功能。它们的原理是帮你把连接 <a href="https://start.spring.io/" target="_blank" rel="noopener">Spring Initializr</a> 并下载解压这个过程自动化了，所以只需要保持网络畅通就行了。</p><table><thead><tr><th align="center">SpringBoot</th><th align="center">Spring + Spring MVC</th></tr></thead><tbody><tr><td align="center"><a href="https://start.spring.io/" target="_blank" rel="noopener">Spring Initializr</a></td><td align="center">1. 安装Tomcat<br>2. 引入spring必要依赖<br>  spring-webmvc<br>spring-context<br>spring-beans<br>spring-aspects<br>…<br>3. 引入必要的第三方依赖，jdbc,test,log这些依赖依然要注意版本兼容问题<br>4. 新建webapp/WEB-INFO/web.xml<br>5. applicationContext.xml<br>6. Springmvc.xml<br>…</td></tr></tbody></table><p>那如果要用原生的springMVC来实现这个事情就复杂了，可以看看右边我大概罗列的这些步骤，当时学的时候让我我非常头疼。要单独安装Tomcat，安装的过程中要注意版本和当前的spring版本是否兼容，手动引入spring各个模块的依赖。pom.xml就不说了，maven工程都要用到，然后还有web.xml-用来配置servlet、拦截规则、字符编码器等等，applicationContext.xml，springmvc.xml 等一大堆xml文件……</p><p>这个过程对初学者非常不友好，记忆这些步骤和配置文件能让人崩溃，xml这种表达方式又不是很直观。这些东西称为脚手架，在小公司里面会搭建这些东西就可以算半个师傅了，小弟们就可以在搭好的架子里面写业务代码了。</p><p>再聊回微服务，试想一下，如果我们要跟上时代的步伐，使用微服务去开发软件，每个功能模块都部署成一个单独的服务，这个时候我们再使用纯粹的 Spring 去开发，每开发一个服务都需要重复的搭建项目骨架，然后编写各种配置文件，几十几百个服务加起来，这部分工作量是很大的，这还不算业务代码的开发时间。这种时候就是 SpringBoot 发挥它开箱即用的特质的时候了。然后多个微服务之间再通过 Spring 全家桶里面的 SpringCloud 进行管理，比如服务注册、服务发现等等。所以我们现在说 SpringBoot 是 Java 企业级开发的一站式解决方案。</p><p><img src="https://i.loli.net/2019/10/28/NDhQZmzAxLRMyjp.jpg" alt="整个世界清静了"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>软件工程是一个不断抽象，不断把复杂的东西简化的这样一套理论和工具，不是说使用起来越复杂就可以彰显我的高端和牛逼，有时候反而是做多错多。所以SpringBoot告诉我们这些工作都没必要，框架来做就行了，你们可以专注于代码逻辑。</p><p>SpringBoot 具有如下优点：</p><ul><li><p>快速创建独立运行的Spring项目以及与主流框架集成、</p></li><li><p>使用嵌入式的Servlet容器，应用无需打成WAR包</p></li><li><p>Starters自动依赖与版本控制</p></li><li><p>大量的自动配置，简化开发，也可修改默认值</p></li><li><p>无需配置XML，无代码生成，开箱即用</p></li><li><p>准生产环境的运行时应用监控</p></li><li><p>与云计算的天然集成</p></li></ul><p>这些优点这篇文章中有的涉及到了，有的还没介绍。我会在之后的文章中陆续把这些话题展开。那么现在，你要做的就是，赶紧把 SpringBoot 用起来吧！</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车站</title>
      <link href="/2019/10/25/che-zhan/"/>
      <url>/2019/10/25/che-zhan/</url>
      
        <content type="html"><![CDATA[<br /><center>三三两两的人</center><center>广告牌里的灯</center><center>影子被拉长，被冲淡</center><br /> <br /> <center>每刻都在擦肩而过</center><center>每天都有失之交臂</center><center>每个人和每个人都保持距离</center><br /> <br /> <center>心思先上路</center><center>第三个路口的便利店</center><center>蛋挞总也吃不腻</center><center>一会儿已经飞到终点</center><center>是目的地、家、或者怀里</center><br /> <br /> <center>也许把大脑放空</center><center>让眼神失去焦距</center><center>每一辆车过</center><center>都能撕出回到现实的间隙</center><center>然后带走一群秘密</center><center>带来一阵张望和匆匆离去</center><br /> <br /> <center>欸～</center><center>上车的乘客请注意</center><center>麻烦往后面挤一挤，挤一挤</center><p align="right">木白</p>            <p align="right">于2016年10月26日</p>            ]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
